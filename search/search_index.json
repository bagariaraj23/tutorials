{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#polygon-id-an-introduction","title":"Polygon ID: An Introduction","text":"<p>Polygon ID\u2019s identity infrastructure facilitates trusted and secure relationships between apps and users, following the principles of self-sovereign identity and privacy by default. Polygon ID enables organizations on one side to issue verifiable credentials about users, and organizations on the other side to verify those claims via a suite of tools created for each member of the SSI ecosystem.</p>"},{"location":"#why-polygon-id","title":"Why Polygon ID?","text":"<p>Polygon ID, with the help of zero-knowledge proofs, lets users prove their identity without the need of exposing their private information. This ensures both the Freedom of Expression and Privacy by Default (User's identities are secured by zero-knowledge cryptography).</p>"},{"location":"#core-concepts-of-polygon-id-verifiable-credentials-identity-holder-issuer-and-verifier-triangle-of-trust","title":"Core Concepts of Polygon ID: Verifiable Credentials, Identity Holder, Issuer and Verifier (Triangle of Trust)","text":"<p>Every identity is identified by a unique identifier called DID (Decentralized Identifier). Every identity-based information is represented via a Verifiable Credentials (VCs).  In the simplest terms, a VC represents any type of information related to an individual/enterprise/object. The VC could be as simple as the age of the entity or the highest degree held by it. It could be a membership certificate issued by a DAO. Or anything that you can think of!</p> <p>The toolset made available by Polygon ID is fully compliant with the W3C standards.</p> <p>The architecture of the framework is composed of three modules: Identity Holder, Issuer, and Verifier. These three, together, form what we call the <code>triangle of trust</code>. Let us see what role each entity plays in Polygon ID. </p> <ol> <li> <p>Identity Holder: An entity that holds claims in its Wallet. A VC, as mentioned above, is issued by an Issuer to the Holder. The Identity Holder generates zero-knowledge proofs of the VCs issued and presents these proofs to the Verifier, which verifies that the proof is authentic and matches specific criteria. </p> </li> <li> <p>Issuer: An entity (person, organization, or thing) that issues VCs to the Holders. VCs are cryptographically signed by the Issuer. Every VC comes from an Issuer. </p> </li> <li> <p>Verifier: A Verifier verifies the proof presented by a Holder. It requests the Holder to send a proof based on the VCs they hold in their wallet. While verifying a proof, the Verifier performs a set of checks, for example that the VC was signed by the expected Issuer and that the VC matches the criteria requested by the Verifier. The simplest examples of a Verifier is a Bar that wants to verify if you are over 18. In the real world, the Identity Holder would need to provide an ID and show all their personal information. With Polygon ID they only need to pass a proof.</p> </li> </ol> <p>A core concept here is the trust that must exist between a Verifier and an Issuer: the fact that the information contained inside a VC are cryptographically verifiable doesn't guarantee its truth. The Issuer must be a trusted and reptuable party so that Verifier can consume the VCs originated by that Issuer.</p> <p>The verification of a VC can happen either off-chain or on-chain!</p> <p></p>"},{"location":"#role-of-a-wallet","title":"Role of a Wallet","text":"<p>A Wallet plays a crucial role in the seamless exchange of VCs with the Issuer, on one hand, and proofs with the Verifier, on the other. As stated above, an Identity Holder carries his/her personal data, in the form of VC, within their wallet. At its core, the wallet stores the private key of a user, fetch VCs from the Issuer, and create zero-knowledge proofs to be presented to the Verifier. Being the carrier of the sensitive information, Wallet has been designed to ensure that the identity of its Holder is protected and preserved, and no sensitive data can be revealed to the third party without the consent of the Holder.  </p>"},{"location":"#what-can-you-achieve-using-polygon-id","title":"What Can you Achieve Using Polygon ID?","text":"<ol> <li> <p>Privacy using Zero-Knowledge Proofs: An Identity Holder, using zero-knowledge proofs, can keep his/her/its personal data private. During the process of VC verification, it just needs to show a proof that he is the owner of a VC that matches certain criteria without letting the Verifier know of the actual VC. For example, an Identity Holder can prove to a Verifier authority that s/he is above 18 years of age by presenting the proof that s/he is above 18 without revealing his/her actual age. This ensures minimum data exposure and hence ensures the safety of any sensitive data.  Another aspect of privacy comes from the fact that the Issuer would not be able to track the usage of VCs by an individual once it has been issued. </p> </li> <li> <p>Off-Chain and On-Chain Verification: Verification of proofs can be done either off-chain or on-chain via Smart Contracts. For example, developers can set up a contract that airdrops tokens only to users that meet certain criteria based on their VCs.</p> </li> <li> <p>Self-Sovereignty: Polygon ID renders self-sovereignty in the hands of the user. The user is the only custodian of his/her private keys; user-controlled data can be shared with third parties without taking any permission from the Issuer that has issued the VCs to the user.</p> </li> <li> <p>Transitive Trust: A transitive trust between the actors of the triangle means that the trust between two entities in one domain or context can be easily extended to other domains or contexts. For instance, the information generated by an Issuer can be conveniently used by more than one Verifier without asking for permission. Along the similar lines, an Identity Hodler can built up his/her trust by collecting multiple credentials from different Issuers in one digital wallet. </p> </li> </ol>"},{"location":"#polygon-id-and-iden3","title":"Polygon ID and Iden3","text":"<p>Iden3 is the open-source protocol at the basis of Polygon ID. The protocol defines on a low-level how the parties listed above communicate and interact with each other. Polygon ID is an abstraction layer to enable developers to build applications leveraging the Iden3 protocol.</p>"},{"location":"#further-resources-on-polygon-id","title":"Further Resources On Polygon ID","text":"<ul> <li>Polygon University - Courses on Polygon ID (free)</li> <li>Identity Layer for Web3 - Paris - July 2022</li> <li>A Deep Dive Into Polygon ID - November 2022</li> <li>A Deeper Dive Into Polygon ID - November 2022</li> </ul>"},{"location":"#further-resources-on-verifiable-credentials","title":"Further Resources On Verifiable Credentials","text":"<ul> <li>Verifiable Credentials: The Ultimate Guide</li> <li>Understanding and Using Verifiable Credentials</li> </ul>"},{"location":"#_1","title":"<p>Polygon ID on GitHub</p>","text":""},{"location":"contracts/overview/","title":"Smart Contracts","text":"<p>Polygon ID Smart Contracts - Github</p>"},{"location":"contracts/overview/#credentialatomicquerysigvalidator","title":"CredentialAtomicQuerySigValidator","text":"<p>CredentialAtomicQuerySigValidator.sol - Github</p> <p>The CredentialAtomicQuerySigValidator contract is used to verify any credential-related zk proof generated by user using the <code>credentialAtomicQuerySigV2OnChain</code> circuit. The contract only verifies proofs based on credential of type <code>Signature</code></p> <p>The core of the contract is its <code>verify</code> function that takes the proof generated by a user and executes a set of verifications:</p> <ul> <li>Verifies that the proof is valid. This verification is actually performed inside the  <code>verifierSig</code> contract which is automatically generated using circom.</li> <li>Verifies that the input used to generate the proof matches the query associated to that specific Request.</li> <li>Verifies that the user's and the Issuer's identity states are valid based on the State Contract.</li> </ul> <p>The CredentialAtomicQuerySigValidator executes the same set of verifications of the Verification Library. The former is required when performing on-chain verification while the latter is required for off-chain verification.</p> <p>CredentialAtomicQuerySigValidator address:</p> <ul> <li>Mumbai: 0xF2D4Eeb4d455fb673104902282Ce68B9ce4Ac450</li> </ul>"},{"location":"contracts/overview/#credentialatomicquerymtpvalidator","title":"CredentialAtomicQueryMTPValidator","text":"<p>CredentialAtomicQueryMTPValidator.sol - Github</p> <p>Performs the same set of verifications of the CredentialAtomicQuerySigValidator but for credential of type <code>MTP</code></p> <p>CredentialAtomicQueryMTPValidator address:</p> <ul> <li>Mumbai: 0x3DcAe4c8d94359D31e4C89D7F2b944859408C618</li> </ul> <p>Further protocol related contracts can found at Iden3 - Smart Contracts</p>"},{"location":"issuer/demo-issuer/","title":"Demo Issuer","text":"<p>The Demo Issuer is a playground that allows you to create credentials without having to set up an Issuer Node and fetch it inside your wallet.</p>"},{"location":"issuer/demo-issuer/#prerequisites","title":"Prerequisites","text":"<p>Download the Polygon ID Wallet App and create an Identity.</p> <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> </ul>"},{"location":"issuer/demo-issuer/#quick-start","title":"Quick Start","text":"<p>To create a credential, you require a schema that contains semantics of the JSON vocabulary and is used to describe a large number of data sets. The schema contains links to JSON-LD Context and JSON URL. For this tutorial, we will be using a customized Schema named <code>ProofOfDaoLongevity</code> that attests to someone's <code>entryDate</code> inside a DAO. You can find more info about that schema and how to create a custom Schema.</p> <p>To create a credential, the Polygon ID app must be installed on your mobile. </p> <ol> <li> <p>On the Issuer website, click Signup.</p> <p> </p> <p>It shows the QR code on screen:</p> <p> </p> </li> <li> <p>Open the Polygon ID app and authenticate with pin/biometrics</p> <p> </p> </li> <li> <p>On the app, click Connect.</p> <p> </p> </li> <li> <p>With the app, scan the QR code displayed on the site and click Connect Wallet. </p> <p> </p> </li> <li> <p>Authenticate again with your pin/biometrics. This starts the authentication of the user's wallet. </p> <p> </p> <p>After the authentication process is complete, the app shows the message if the identity is successfully authenticated or if it failed to authenticate.  </p> <p> </p> <p>At this point, the Issuer has received information about your Identifier (DID) and can use it as the subject of the credential that will be issued in the next step.</p> </li> <li> <p>On the website, click Create Claim.</p> <p> </p> <p>This shows the Create Claim window:</p> <p> </p> </li> <li> <p>Click the Schema dropdown menu and select the type of schema you want to use for creating credentials. </p> <p>Two schemas types are already available in the drop-down menu: KYCAgeCredential and KYCCountryOfResidenceCredential.  If you want to use a custom schema, select custom from the drop-down menu. For this example, we are using the <code>ProofOfDaoLongevity</code> schema created in the Create Custom Schemas tutorial. The menu needs to be populated with the JSON Schema URL and the Type of the schema. Which in this case are: </p> <ul> <li><code>https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.json</code></li> <li><code>ProofOfDaoLongevity</code></li> </ul> <p>The expiration date sets the date on which the credential will expire.  The Data JSON contains the actual data that the credential is attesting to. In this case, the credential contains a single field <code>entryDate</code> that needs to be populated with the date the user joined the DAO.</p> <p>Once filled up, click Submit.</p> <p> </p> <p>This creates a new credential. Scan the QR code from the wallet app to fetch the credential in the wallet.</p> <p> </p> </li> <li> <p>Once a credential is created, you can view it on the Issuer site. For this, click the icon to open and view the credential. </p> <p> </p> </li> </ol> <p>This shows all the information related to a credential; this includes:</p> <ul> <li>@Context (JSON-LD Schema) and CredentialSchema (JSON) URLs</li> <li>credentialStatus: URL to fetch the Revocation status of the credential from the Issuer along with the revocation nonce. </li> <li>credentialSubject: Information related to the Subject of the Credential. In this example, this includes subject's  <code>entryDate</code> and id of the Subject in the <code>did</code> format.</li> <li>Other information such as expiration date of the credential, issuance date, and id of the Issuer in the <code>did</code> format.</li> <li>Proof which includes information such as state of the issuer identity published on-chain, the non-revocation proof for the authorization claim, and the actual credential signed by the Issuer. </li> </ul>"},{"location":"issuer/issuer-overview/","title":"Issuer Overview","text":"<p>An Issuer is any subject that issues Verifiable Credentials. You can think of a credentials as a statement: something an Issuer says about another subject. For example, when a university (Issuer) says that a student (subject) has a degree, this is a credential.</p> <p>An issuer might be: </p> <ul> <li>A DAO that issues \u201cmembership claims\" to its members.</li> <li>A Government that issues ID to its citizens.</li> <li>A Face detection ML application that issues \"proof of personhood\" claims. </li> <li>An employer that endorses its employees.</li> </ul> <p>Verifiable Credentials are a flexible data format able to express any type of information so that developers can unleash their creativity.</p> <p>To operate, an Issuer must run an Issuer Node, which is a self-hosted Node that exposes all the functionalities necessary to run an issuer.</p> <p>Using Polygon ID an Issuer can issue Credentials to their users (or friends!).</p> <p>Alternatively, you can quickly try out the Credential Issuance experience using the Demo Issuer.</p>"},{"location":"issuer/schema/","title":"Create Custom Schemas","text":"<p>A Schema Type encodes the structure of a particular Verifiable Credential (VC) by defining the new of the type, the fields that must be included inside the VC, and a description for these fields.</p> <p>Schemas are a crucial component that allows for the interoperable use of VCs across different services. Just by parsing a schema, any program can interpret the content of a Verifiable Credential without having to interact with Issuer Party.</p> <p>In order to issue Verifiable Credentials, you can refer to existing schemas. If the existing ones are not able to describe the type of data you desire, you need to create your own schema <code>Type</code>.</p> <p>A schema type is made of two documents:</p> <ul> <li> <p><code>JSON-LD Context</code>, which contains a description of the type and its fields. Here is an example of JSON-LD Context for Schema Type <code>KYCAgeCredential</code></p> </li> <li> <p><code>JSON Schema</code> which contains the validation rules for the Issuer Node. Here is an example of a JSON Schema for Schema Type <code>KYCAgeCredential</code>.</p> </li> </ul> <p>Without further ado, let's jump into building a new Schema Type!</p>"},{"location":"issuer/schema/#tutorial","title":"Tutorial","text":"<p>Note: The executable code and further schemas examples for this section can be found here. </p> <p>We are a DAO that wants to issue VC to its members. Unfortunately, there's no existing schemas that can accommodate this type of data attestation. In order to issue these VCs, a schema of type <code>ProofOfDaoLongevity</code> needs to be created. This example will show you how to create a schema type that contains a single field, you can extend it to include more fields.</p> <p>1. Define which field to include in the schema</p> <p>The <code>ProofOfDaoLongevity</code> should include a field defined <code>entryDate</code> able to attest the specific date when one joined the DAO. A credential can contain as many fields as you want!</p> <p>2. Create the vocabulary of the Schema Type</p> <p>Create a markdown file in your git repository to describe the vocabulary used inside the Schema Type. We decide to name the file <code>proof-of-dao-longevity-vocab.md</code>. This should contain a description of the (only) field <code>entryDate</code> included in the schema type.</p> <pre><code># entryDate\n\nDescribes the date when a contributor joined the DAO\n</code></pre> <p>3. Create the JSON-LD Context</p> <p>Create a <code>.jsonld</code> file in your repository to contain the JSON-LD Context of the Schema Type. We decide to name it <code>proof-of-dao-longevity.jsonld</code>.</p> <p>The JSON-LD Context contains:</p> <ul> <li> <p>the name of the Type</p> </li> <li> <p>its unique identifier <code>@id</code> which is a public url where the context can be resolved. </p> <p>If you are working on Github, you can fetch the url directly from your published repository based on the file path. In this case it is </p> <p><code>https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.jsonld#ProofOfDaoLongevity</code></p> </li> <li> <p>the definition of the vocabulary with its url</p> <p>In this case we create a field defined <code>vocab</code> and attach the url that identifies the vocabulary. In this case it is </p> <p><code>https://github.com/0xPolygonID/tutorial-examples/blob/main/credential-schema/proof-of-dao-longevity-vocab.md#</code></p> </li> <li> <p>The field that we want to include inside the credential, defined together with its identifier and its data type (all xsd data type are available)</p> <pre><code>{\n\"@context\": [\n{\n\"@version\": 1.1,\n\"@protected\": true,\n\"id\": \"@id\",\n\"type\": \"@type\",\n\"ProofOfDaoLongevity\": {\n\"@id\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.jsonld#ProofOfDaoLongevity\",\n\"@context\": {\n\"@version\": 1.1,\n\"@protected\": true,\n\"id\": \"@id\",\n\"type\": \"@type\",\n\"vocab\": \"https://github.com/0xPolygonID/tutorial-examples/blob/main/credential-schema/proof-of-dao-longevity-vocab.md#\",\n\"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n\"entryDate\": {\n\"@id\": \"vocab:entryDate\",\n\"@type\": \"xsd:integer\"\n}\n}\n}\n}\n]\n}\n</code></pre> </li> </ul> <p>Note: The lines which are underlined are the only ones that need to be modified in order to create a new Schema Type.</p> <p>5. Create the JSON Schema</p> <p>Last but not least, we have to create the JSON Schema Document.  We decide to name it <code>proof-of-dao-longevity.json</code>. This a document that contains the serialization rule and the instruction for the Issuer to build Verifiable Credentials based on a specific schema type and spot any error in the process. Although it might seem complex and verbose, there are just a few values that need to be updated to adapt to your purpose:</p> <ul> <li> <p>Add the <code>uris</code> to your specific <code>jsonLdContext</code> and <code>jsonSchema</code></p> </li> <li> <p>Inside <code>CredentialSubject</code> update the information related to your field</p> <pre><code>{\n\"$schema\": \"http://json-schema.org/draft-07/schema#\",\n\"type\": \"object\",\n\"$metadata\": {\n\"uris\": {\n\"jsonLdContext\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.jsonld\",\n\"jsonSchema\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/proof-of-dao-longevity.json\"\n}\n},\n\"required\": [\n\"@context\",\n\"id\",\n\"type\",\n\"issuanceDate\",\n\"credentialSubject\",\n\"credentialSchema\",\n\"credentialStatus\",\n\"issuer\"\n],\n\"properties\": {\n\"@context\": {\n\"type\": [\n\"string\",\n\"array\",\n\"object\"\n]\n},\n\"id\": {\n\"type\": \"string\"\n},\n\"type\": {\n\"type\": [\n\"string\",\n\"array\"\n],\n\"items\": {\n\"type\": \"string\"\n}\n},\n\"issuer\": {\n\"type\": [\n\"string\",\n\"object\"\n],\n\"format\": \"uri\",\n\"required\": [\n\"id\"\n],\n\"properties\": {\n\"id\": {\n\"type\": \"string\",\n\"format\": \"uri\"\n}\n}\n},\n\"issuanceDate\": {\n\"type\": \"string\",\n\"format\": \"date-time\"\n},\n\"expirationDate\": {\n\"type\": \"string\",\n\"format\": \"date-time\"\n},\n\"credentialSchema\": {\n\"type\": \"object\",\n\"required\": [\n\"id\",\n\"type\"\n],\n\"properties\": {\n\"id\": {\n\"type\": \"string\",\n\"format\": \"uri\"\n},\n\"type\": {\n\"type\": \"string\"\n}\n}\n},\n\"subjectPosition\": {\n\"type\": \"string\",\n\"enum\": [\n\"none\",\n\"index\",\n\"value\"\n]\n},\n\"merklizationRootPosition\": {\n\"type\": \"string\",\n\"enum\": [\n\"none\",\n\"index\",\n\"value\"\n]\n},\n\"revNonce\": {\n\"type\": \"integer\"\n},\n\"version\": {\n\"type\": \"integer\"\n},\n\"updatable\": {\n\"type\": \"boolean\"\n},\n\"credentialSubject\": {\n\"type\": \"object\",\n\"required\": [\n\"id\",\n\"entryDate\"\n],\n\"properties\": {\n\"id\": {\n\"title\": \"Credential Subject ID\",\n\"type\": \"string\",\n\"format\": \"uri\"\n},\n\"entryDate\": {\n\"type\": \"integer\"\n}\n}\n}\n}\n}\n</code></pre> </li> </ul> <p>6. Publish it!</p> <p>If you were working on a git repository, push all the files, make sure that the repo is public and that's it!</p>"},{"location":"issuer/schema/#further-resources","title":"Further Resources","text":"<ul> <li>JSON-LD - W3C VC Standard</li> <li>JSON-LD Context - W3C VC Standard </li> </ul>"},{"location":"issuer/platform-api/introduction/","title":"Polygon ID Platform API","text":"<p>The Polygon ID Platform API exposes all the functionalities necessary to run an issuer.</p> <p>To become familiar with the role of the issuer, it is advised to use  Polygon Platform UI as a testing sandbox. All the functionalities included in the UI are exposed here as independent APIs.</p> <p>The core functionality of the Platform API are:</p> <ul> <li>Onboarding Orgs to register and manage an Organization Account</li> <li>Issuer to set up an Issuer</li> <li>Schemas to create and manage Claim Schemas</li> <li>Claim Offers to issue Claims based on existing schemas and offer them to your users via a QR code</li> </ul> <p></p> <p>Disclaimer: Polygon ID APIs will be subject to improvments and changes in the upcoming months.</p> <p>The APIs categories are sequential steps: you cannot start creating Schemas and issuing claims without having an Issuer. Similarly, you need an Organization account to create an Issuer on Polygon ID Platform. To start playing around with the Platform APIs, complete the Issuer Integration Full Flow Tutorial</p>"},{"location":"issuer/platform-api/introduction/#core-resources","title":"Core resources:","text":"<ul> <li>OpenAPI specification for API Methods</li> <li>Postman collection for API Methods</li> </ul>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/","title":"Getting Started - Full Flow Tutorial","text":"<p>This tutorial will walk you through a Full Flow Issuer Integration using Polygon ID APIs. </p> <p>The main role of the issuer is to Issue Claims. In this tutorial, you'll impersonate a DAO that wants to issue claims for its contributors. In particular, the Claim itself will contain two type of information: the \"Season\" in which the contributor joined the DAO and its role inside the DAO. By the end of the tutorial, every contributor will be able to use their Polygon ID App to scan a QR code and receive a claim inside their wallet attesting their information as DAO contributor.</p> <p>The tutorial is made of 9 steps: </p> <ol> <li>Create an Organization Account</li> <li>Sign-in to an Organization Account</li> <li>Activate your Organization Account</li> <li>Create an Issuer</li> <li>Refresh the Token</li> <li>Create a Schema</li> <li>Create Claim Offer</li> <li>Create QR Code of Claim Offer</li> <li>Get a QR Code of Offer</li> </ol>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#initial-set-up","title":"Initial Set Up","text":"<p>We already created a Postman Collection to make your life easier. To start, access the Polygon ID Postman Collection. From the left-hand side menu click on \"Collections\" and then \"Create a Fork\". This will fork the Collection inside your private workspace. Once you moved into your private workspace there are different ways in which you can start testing the endpoints:</p> <ul> <li>Using the built-in Postman Platform allows you to make API calls directly from your browser.</li> </ul> <p> </p> <ul> <li>Using auto-generated code snippets from Postman in Axios, cURL, Python, HTTP and many more.</li> </ul> <p> </p> <p>In this tutorial we are using cURL code snippet to make API calls. Nevertheless any method will generate the same output.</p>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#1-create-an-organization-account","title":"1. Create An Organization Account","text":"<p>The first mandatory thing is to create an account for your Organization passing in an <code>email</code> and <code>password</code>. This action is performed via the Create Organization Endpoint. The password and the email must be passed inside the Body Request. This action has to be executed only once. </p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/orgs/account-management' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"email\": \"mypersonalemail2@test.com\",\n    \"password\": \"Some123456789123123Pwd!\"\n}'\n</code></pre> <p>Remember to modify the <code>email</code> otherwise you'll get an error message as this email is already associated to an Organization Account</p> <p>The response contains the details of the newly created Organization Account. The <code>verified</code> key is equal to <code>false</code>. It means that the account still requires to be activated. This action will be performed in step 3](#3-activate-your-organization-account) of this tutorial.</p> <pre><code>{\n    \"createdAt\": \"2022-11-28T10:34:01.825579Z\",\n    \"email\": \"mypersonalemail2@test.com\",\n    \"id\": \"d926a8c4-6545-4e00-aa26-53b7055d10cd\",\n    \"modifiedAt\": \"2022-11-28T10:34:01.825579Z\",\n    \"type\": \"OWNER\",\n    \"verified\": false\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#2-sign-in-to-an-organization-account","title":"2. Sign-in to an Organization Account","text":"<p>The credential used to create your Organization Account are then used to Sign-in into your Organization Account. This action is performed via the Sign-in Endpoint. The <code>email</code> and <code>password</code> used previously to create the Organization Account need to be passed inside the Body Request.  This action needs to be executed in order to perform every further action within Polygon ID APIs.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/orgs/sign-in' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"email\": \"mypersonalemail2@test.com\",\n    \"password\": \"Some123456789123123Pwd!\"\n}'\n</code></pre> <p>The Response Body contains a JWT <code>Bearer Token</code>. This token will be used in order to authenticate yourself as a Signed-in Organization Account and get the authorization to use the API Endpoints.</p> <pre><code>{\n\"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxMTYsImp0aSI6IjFmYTQ2NDAwLWU5YTgtNGExYS05OTEwLWQ3MjA3MDM2OTA1NCIsImlhdCI6MTY2OTYzMTcxNiwibmJmIjoxNjY5NjMxNzE2LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOmZhbHNlLCJvcmdhbml6YXRpb24iOm51bGwsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.3h5_EZjCT2vzX3xHodJ6XhZRdKoZRxPH0bobEUHUDIQ\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#3-activate-your-organizations-account","title":"3. Activate your Organization's Account","text":"<p>Now it is mandatory to Activate your Organization Account. This action is performed via the Activate Endpoint. The <code>Bearer Token</code> generated from the last request needs to be passed inside the Authorization Request Header. This action has to be executed only once.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/orgs/account-management/activate' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxMTYsImp0aSI6IjFmYTQ2NDAwLWU5YTgtNGExYS05OTEwLWQ3MjA3MDM2OTA1NCIsImlhdCI6MTY2OTYzMTcxNiwibmJmIjoxNjY5NjMxNzE2LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOmZhbHNlLCJvcmdhbml6YXRpb24iOm51bGwsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.3h5_EZjCT2vzX3xHodJ6XhZRdKoZRxPH0bobEUHUDIQ' \\\n--data-raw ''\n</code></pre> <p>The Response Body contains an updated JWT <code>Bearer Token</code> that attests that the Organization Account has been activated.</p> <pre><code>{\n\"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxNzUsImp0aSI6IjJmZTE1NmYzLWM0ZTUtNGZjNi05NDYzLWNlZmIzN2EzMWE2MCIsImlhdCI6MTY2OTYzMTc3NSwibmJmIjoxNjY5NjMxNzc1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6bnVsbCwicm9sZSI6Ik9XTkVSIiwiZW1haWwiOiJteXBlcnNvbmFsZW1haWwyQHRlc3QuY29tIn19.daxoACgJFW9E5rWc2E2bUCNl6boIsHe-bE6UmUrgC04\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#4-create-an-issuer","title":"4. Create an Issuer","text":"<p>Before starting Issuing Claims, it is necessary to set up an Issuer. To set up an issuer it is required to have an Organization Account activated and signed-in. Each Organization Account can only manage a single Issuer. This action is performed via the Create Issuer Endpoint. </p> <p>This Endpoint requires to pass various details about the Issuer such as its <code>displayName</code> (required) and other optional parameters such as <code>legalName</code>, <code>logo</code> and <code>region</code>. The displayName and the logo are public values that will be visible to the user, while legalName and region will not be shown to the outside. The logo data file needs to be filled with an image encoded in base64 format. Lastly, the <code>Bearer Token</code> generated from the last request needs to be passed inside the Authorization Request Header. This action has to be executed only once.</p> <p>Today an Organization can only set up one Issuer. Soon more actions will be enabled for an Organization such as setting up multiple Issuers or a Verifier.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/issuers' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxNzUsImp0aSI6IjJmZTE1NmYzLWM0ZTUtNGZjNi05NDYzLWNlZmIzN2EzMWE2MCIsImlhdCI6MTY2OTYzMTc3NSwibmJmIjoxNjY5NjMxNzc1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6bnVsbCwicm9sZSI6Ik9XTkVSIiwiZW1haWwiOiJteXBlcnNvbmFsZW1haWwyQHRlc3QuY29tIn19.daxoACgJFW9E5rWc2E2bUCNl6boIsHe-bE6UmUrgC04' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"displayName\" : \"IssuerTest1234\",\n    \"legalName\" : \"IssuerLegalOrg1\",\n    \"logo\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=\",\n    \"region\" : \"USA\"\n}'\n</code></pre> <p>The Response Body contains the details of the newly created Issuer. Later on, you'll be referring to this Issuer by its <code>id</code>.</p> <pre><code>{\n\"createdAt\": \"2022-11-28T10:38:10.639675Z\",\n\"did\": \"114uHUxT37dnr4JJiAcsE9mNK2PKWm9umrHNuM8S35\",\n\"displayName\": \"IssuerTest1234\",\n\"id\": \"40b4018f-83f1-4db5-a878-c2d002ef6532\",\n\"legalName\": \"IssuerLegalOrg1\",\n\"logo\": \"https://s3.eu-west-1.amazonaws.com/polygonid-assets/logo/12fa8d61-0b32-4827-a6ea-9f31acdb3f1b\",\n\"modifiedAt\": \"2022-11-28T10:38:10.639675Z\",\n\"ownerEmail\": \"mypersonalemail2@test.com\",\n\"region\": \"USA\",\n\"slug\": \"issuertest1234\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#5-refresh-the-token","title":"5. Refresh the Token","text":"<p>The next step is to Refresh the Bearer Token in order to add to it the updated information regarding the newly created Issuer such as its <code>id</code>. This action is performed via the Refresh Token Endpoint. The last valid <code>Bearer Token</code> (the one generated in step 3) needs to be passed inside the Authorization Request Header. </p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/orgs/account-management/refresh-token' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgxNzUsImp0aSI6IjJmZTE1NmYzLWM0ZTUtNGZjNi05NDYzLWNlZmIzN2EzMWE2MCIsImlhdCI6MTY2OTYzMTc3NSwibmJmIjoxNjY5NjMxNzc1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6bnVsbCwicm9sZSI6Ik9XTkVSIiwiZW1haWwiOiJteXBlcnNvbmFsZW1haWwyQHRlc3QuY29tIn19.daxoACgJFW9E5rWc2E2bUCNl6boIsHe-bE6UmUrgC04'\n</code></pre> <p>The Response Body contains a refreshed JWT <code>Bearer Token</code> with the updated details regarding the Issuer added to the Organization Account.</p> <pre><code>{\n\"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgzMzUsImp0aSI6IjcyZDM4NzVhLTI4MTQtNDY0YS04NzIxLWExYmY3NDY2M2ZiYiIsImlhdCI6MTY2OTYzMTkzNSwibmJmIjoxNjY5NjMxOTM1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6IjQwYjQwMThmLTgzZjEtNGRiNS1hODc4LWMyZDAwMmVmNjUzMiIsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.BjwZuIiI1ekSbrlAz_eCFLmWoEiH-PgUDgf-3g5TV8E\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#6-create-a-schema","title":"6. Create a Schema","text":"<p>Before issuing the actual Claims, it is necessary to define a Schema. In simple terms, a Schema defines the structure of the Claim, while a Claim is generated by starting from the structure defined by a Schema and filling it up with actual data.  </p> <p></p> <p>In this case, the Schema, named <code>daoContributor2</code> will define that the Claim must contain two different attributes:</p> <ul> <li>An attribute defined <code>CoreContributor</code> that defines whether the user is a core contributor for the DAO or not.</li> <li>An attributed define <code>SinceSeason</code> that contains the number of the DAO Season in which the contributor Joined. </li> </ul> <p>This action is performed via the Create Schema Endpoint. It requires passing a set of values inside the Body Request: </p> <ul> <li>The name of the <code>schema</code>, which in this case is daoContributor2</li> <li>The <code>mandatoryExpiration</code> of the schema, which in this case we set to false</li> <li>An array of <code>attributes</code>, which contains the details of the attributes defined previously, such as their <code>name</code>, <code>description</code> and <code>type</code>. The attribute <code>CoreContributor</code> is of type boolean while <code>SinceSeason</code> is of type number</li> </ul> <p>The refreshed <code>Bearer Token</code> from the last step needs to be passed inside the Authorization Request Header. Furthermore, it requires to pass the issuer <code>id</code> as Path Parameter. An Issuer can create as many schemas he/she wants!</p> <p>you can retreive the Issuer ID from the response obtained in Step 4 or by parsing the latest JWT token here and checking the <code>organization</code> field.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/issuers/40b4018f-83f1-4db5-a878-c2d002ef6532/schemas' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgzMzUsImp0aSI6IjcyZDM4NzVhLTI4MTQtNDY0YS04NzIxLWExYmY3NDY2M2ZiYiIsImlhdCI6MTY2OTYzMTkzNSwibmJmIjoxNjY5NjMxOTM1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6IjQwYjQwMThmLTgzZjEtNGRiNS1hODc4LWMyZDAwMmVmNjUzMiIsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.BjwZuIiI1ekSbrlAz_eCFLmWoEiH-PgUDgf-3g5TV8E' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"schema\": \"daoContributor2\",\n  \"mandatoryExpiration\": false,\n  \"attributes\": [\n    {\n      \"name\": \"CoreContributor\",\n      \"type\": \"boolean\",\n      \"description\": \"Role as contributor in the DAO\"\n    },\n    {\n    \"name\": \"SinceSeason\",\n      \"type\": \"number\",\n      \"description\": \"Number of season in which the contributor joined the DAO\"\n    }\n  ]\n}'\n</code></pre> <p>The response contains the details of the newly created schema. Later on, you'll be referring to this Schema by its <code>id</code></p> <pre><code>{\n\"active\": true,\n\"attributes\": [\n{\n\"description\": \"Role as contributor in the DAO\",\n\"name\": \"CoreContributor\",\n\"type\": \"boolean\"\n},\n{\n\"description\": \"Number of season in which the contributor joined the DAO\",\n\"name\": \"SinceSeason\",\n\"type\": \"number\"\n}\n],\n\"createdAt\": \"2022-11-28T11:35:17.066679Z\",\n\"id\": \"88a9b947-31b9-443e-8473-4344949815b4\",\n\"issuerID\": \"40b4018f-83f1-4db5-a878-c2d002ef6532\",\n\"mandatoryExpiration\": false,\n\"modifiedAt\": \"2022-11-28T11:35:17.066679Z\",\n\"schema\": \"daoContributor2\",\n\"schemaHash\": \"f877157e9a88239180178212736c5e7e\",\n\"schemaURL\": \"https://s3.eu-west-1.amazonaws.com/polygonid-schemas/8589aba5-e973-4dab-9cac-0955731f4d27.json-ld\",\n\"technicalName\": \"\",\n\"version\": \"1.1\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#7-create-claim-offer","title":"7. Create Claim Offer","text":"<p>Now it's time to actually create a Claim. We already have a schema, now we just need to fill it up with data of a user. We do that by assigning values to the attributes defined in the Schema Creation.</p> <p>Let's consider the case of Issuing a Claim to a user that has been part of a DAO since season 4 as a Core Contributor. This action is performed via the Create Offer Endpoint. It requires passing an array of <code>attributes</code> inside the Body Request. Each attribute object contains the <code>attributeKey</code>, namely the name of the Schema Attribute it refers to, and the <code>attributeValue</code>, namely the value to be assigned to that specific attributeKey. </p> <p>Setting up the logic to verify the role of a Contributor inside the DAO and the Season he/she joined it are responsability of the implementer.</p> <p>A valid <code>Bearer Token</code> needs to be passed inside the Authorization Request Header. Furthermore, it requires to pass the Issuer <code>id</code> and the Schema <code>id</code> as Path Parameters. You can find the Schema id inside the Response Body in step 6.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/issuers/40b4018f-83f1-4db5-a878-c2d002ef6532/schemas/88a9b947-31b9-443e-8473-4344949815b4/offers' \\\n--header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Njk3MTgzMzUsImp0aSI6IjcyZDM4NzVhLTI4MTQtNDY0YS04NzIxLWExYmY3NDY2M2ZiYiIsImlhdCI6MTY2OTYzMTkzNSwibmJmIjoxNjY5NjMxOTM1LCJzdWIiOiJkOTI2YThjNC02NTQ1LTRlMDAtYWEyNi01M2I3MDU1ZDEwY2QiLCJzY29wZSI6ImFwaSIsImFjY291bnQiOnsidmVyaWZpZWQiOnRydWUsIm9yZ2FuaXphdGlvbiI6IjQwYjQwMThmLTgzZjEtNGRiNS1hODc4LWMyZDAwMmVmNjUzMiIsInJvbGUiOiJPV05FUiIsImVtYWlsIjoibXlwZXJzb25hbGVtYWlsMkB0ZXN0LmNvbSJ9fQ.BjwZuIiI1ekSbrlAz_eCFLmWoEiH-PgUDgf-3g5TV8E' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"attributes\": [\n        {\n            \"attributeKey\": \"CoreContributor\", \n            \"attributeValue\": 1\n        },\n        {\n            \"attributeKey\": \"SinceSeason\", \n            \"attributeValue\": 4\n        }\n    ]\n}'\n</code></pre> <p>You can only pass numeric values as <code>attributeValue</code>. That's why we cannot define the attributeValue for the key CoreContributor as true. Instead, we assign 1 which corresponds to true. If it was false, the corresponsing value would have been 0</p> <p>The response contains the details of the newly created Claim. In particular, you can see that the DAO contributor data are defined inside the <code>attributeValues</code> field. Later on, you'll be referring to this Claim by its <code>id</code></p> <pre><code>{\n\"attributeValues\": [\n{\n\"attributeKey\": \"CoreContributor\",\n\"attributeValue\": 1\n},\n{\n\"attributeKey\": \"SinceSeason\",\n\"attributeValue\": 4\n}\n],\n\"attributes\": [\n{\n\"description\": \"Role as contributor in the DAO\",\n\"name\": \"CoreContributor\",\n\"type\": \"boolean\"\n},\n{\n\"description\": \"Number of season in which the contributor joined the DAO\",\n\"name\": \"SinceSeason\",\n\"type\": \"number\"\n}\n],\n\"createdAt\": \"2022-11-28T11:39:03.845512Z\",\n\"expiresAt\": null,\n\"id\": \"cc3570ed-2bae-4b4c-b2f9-11f636a30151\",\n\"limitedClaims\": null,\n\"schemaTemplateID\": \"88a9b947-31b9-443e-8473-4344949815b4\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#8-create-qr-code-of-claim-offer","title":"8. Create QR Code of Claim Offer","text":"<p>The claim has now been created. Now we need to share it with the designated DAO Contributor. This action is performed via the Create QRCode of Offer Endpoint. This Endpoint only requires to pass the Claim <code>id</code> as Path Parameter.</p> <pre><code>curl --location --request POST 'https://api-staging.polygonid.com/v1/offers-qrcode/cc3570ed-2bae-4b4c-b2f9-11f636a30151'\n</code></pre> <p>The response contains the details of the claim Offer, identified via its <code>id</code>. In particular, it generates a <code>sessionID</code> for the user to authenticate and fetch the claim inside their wallet. With this endpoint, a <code>qrcode</code> gets created and associated with that user. This QR Code has to be displayed to the specific DAO Contributor that is entitled to receive the claim. The sessionID expires in 2 minutes after which the qrcode will no longer be scannable.</p> <pre><code>{\n\"issuer\": {\n\"displayName\": \"IssuerTest1234\",\n\"logo\": \"https://s3.eu-west-1.amazonaws.com/polygonid-assets/logo/12fa8d61-0b32-4827-a6ea-9f31acdb3f1b\"\n},\n\"offerDetails\": {\n\"attributeValues\": [\n{\n\"attributeKey\": \"CoreContributor\",\n\"attributeValue\": 1\n},\n{\n\"attributeKey\": \"SinceSeason\",\n\"attributeValue\": 4\n}\n],\n\"attributes\": [\n{\n\"description\": \"Role as contributor in the DAO\",\n\"name\": \"CoreContributor\",\n\"type\": \"boolean\"\n},\n{\n\"description\": \"Number of season in which the contributor joined the DAO\",\n\"name\": \"SinceSeason\",\n\"type\": \"number\"\n}\n],\n\"createdAt\": \"2022-11-28T11:39:03.845512Z\",\n\"expiresAt\": null,\n\"id\": \"cc3570ed-2bae-4b4c-b2f9-11f636a30151\",\n\"limitedClaims\": null,\n\"schemaTemplateID\": \"88a9b947-31b9-443e-8473-4344949815b4\",\n\"schemaTemplateName\": \"daoContributor2\"\n},\n\"qrcode\": {\n\"body\": {\n\"callbackUrl\": \"https://api-staging.polygonid.com/v1/offers-qrcode/cc3570ed-2bae-4b4c-b2f9-11f636a30151/callback?sessionID=9d0a2cb5-9020-4e7e-af54-c4c067fcd391\",\n\"reason\": \"auth login\",\n\"scope\": []\n},\n\"from\": \"114uHUxT37dnr4JJiAcsE9mNK2PKWm9umrHNuM8S35\",\n\"id\": \"0cf483fa-0b3d-46f3-8e47-7c2dafe9da05\",\n\"thid\": \"0cf483fa-0b3d-46f3-8e47-7c2dafe9da05\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/authorization/1.0/request\"\n},\n\"sessionID\": \"9d0a2cb5-9020-4e7e-af54-c4c067fcd391\"\n}\n</code></pre>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#9-fetch-the-claim-inside-users-wallet","title":"9. Fetch the claim inside User's wallet","text":"<p>To fetch a claim inside their wallet, the user either needs to scan a QR code or use deeplinking. After scanning the QR Code or clicking the deeplink, the user will be required to authenticate. On successful authentication, they will receive a notification to add the claim inside their wallet.</p>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#9a-via-qr-code","title":"9.a. Via QR Code","text":"<p>To Download the QRCode previously created as PNG file we use the Download a QRCode of Offer Endpoint. For it, we need to pass the claim offer <code>id</code>, generated in step 7, as Path Parameter and the <code>sessionID</code>, generated from the previous step, as Query Parameter.</p> <pre><code>curl --location --request GET 'https://api-staging.polygonid.com/v1/offers-qrcode/cc3570ed-2bae-4b4c-b2f9-11f636a30151/download?sessionID=9d0a2cb5-9020-4e7e-af54-c4c067fcd391'\n</code></pre> <p>the --output flag is necessary to tell where to save the output file</p> <p></p>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#9b-via-deep-linking","title":"9.b. Via Deep Linking","text":"<p>The same Claim Offer can also be delivered to users via Deep Linking. In order to do so is necessary to encode the <code>qrcode</code> file obtained from step 8 to Base64 Format. The related deep link would be <code>iden3comm://?i_m={{base64EncodedRequestHere}}</code>. For example, in this specific case the deep link would be <code>iden3comm://?i_m=ewogICAgICAgICJib2R5IjogewogICAgICAgICAgICAiY2FsbGJhY2tVcmwiOiAiaHR0cHM6Ly9hcGktc3RhZ2luZy5wb2x5Z29uaWQuY29tL3YxL29mZmVycy1xcmNvZGUvY2MzNTcwZWQtMmJhZS00YjRjLWIyZjktMTFmNjM2YTMwMTUxL2NhbGxiYWNrP3Nlc3Npb25JRD05ZDBhMmNiNS05MDIwLTRlN2UtYWY1NC1jNGMwNjdmY2QzOTEiLAogICAgICAgICAgICAicmVhc29uIjogImF1dGggbG9naW4iLAogICAgICAgICAgICAic2NvcGUiOiBbXQogICAgICAgIH0sCiAgICAgICAgImZyb20iOiAiMTE0dUhVeFQzN2RucjRKSmlBY3NFOW1OSzJQS1dtOXVtckhOdU04UzM1IiwKICAgICAgICAiaWQiOiAiMGNmNDgzZmEtMGIzZC00NmYzLThlNDctN2MyZGFmZTlkYTA1IiwKICAgICAgICAidGhpZCI6ICIwY2Y0ODNmYS0wYjNkLTQ2ZjMtOGU0Ny03YzJkYWZlOWRhMDUiLAogICAgICAgICJ0eXAiOiAiYXBwbGljYXRpb24vaWRlbjNjb21tLXBsYWluLWpzb24iLAogICAgICAgICJ0eXBlIjogImh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9hdXRob3JpemF0aW9uLzEuMC9yZXF1ZXN0IgogICAgfQ==</code></p>"},{"location":"issuer/platform-api/flow-tutorial/happy-path/#optional-10-get-qrcode-of-offer","title":"(OPTIONAL) 10. Get QRCode of Offer","text":"<p>The notification will only show up if the user has turned on the notifications for Polygon ID App. If that's not the case, the user will need to scan a second QR Code to fetch the claim inside their wallet. This action is performed via the Get QRCode of Offer.</p>"},{"location":"issuer/platform-api/issuer/apis/","title":"Issuer","text":"<p>The Issuer endpoints represent all the actions needed to manage an Issuer, such as Creating, Updating or Deleting an Issuer. Each Organization Account can only manage a single Issuer. </p>"},{"location":"issuer/platform-api/issuer/apis/#create-issuer","title":"Create Issuer","text":"<p>Function: Endpoint to create a new Issuer for an Organization Account. </p> <p>How it works: It requires passing the name of the Issuer <code>displayName</code> as required Request Body parameters. Other non-required Request Body parameters are the <code>logo</code>, the <code>legalName</code> and the <code>region</code> of your Issuer. This information will represent your Polygon ID Issuer profile. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains a set of details related to the newly created Issuer such as its <code>id</code>. </p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/issuer/apis/#get-issuer","title":"Get Issuer","text":"<p>Function: Endpoint to fetch key information about an Issuer.</p> <p>How it works: It requires passing the Issuer <code>id</code> as Path Parameter. This endpoint can be used to fetch information about any issuer existing on Polygon ID. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the entire set of details related to the requested Issuer.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/issuer/apis/#update-issuer","title":"Update Issuer","text":"<p>Function: Endpoint to update the details of an existing Issuer. </p> <p>How it works: It allows passing the <code>displayName</code>, <code>logo</code>, <code>legalName</code> and <code>region</code> as optional Request Body parameters. You can choose passing only one of these value or all of them according to the type of information about the Issuer to update. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the entire set of details related to the updated Issuer.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/issuer/apis/#delete-issuer","title":"Delete Issuer","text":"<p>Function: Endpoint to delete an existing Issuer. </p> <p>How it works: It requires passing the Issuer <code>id</code> as Path Parameter. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. As a result of this Request the Issuer will be deleted and no longer able to perform actions on Polygon ID Platform.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/","title":"Claim Offers","text":"<p>Once an Issuer has been set up and created schemas, they can start offering Claims to their users. A Claim Offer is a Schema filled with data of actual users delivered to users' Wallets.</p>"},{"location":"issuer/platform-api/offers/apis/#create-offer","title":"Create Offer","text":"<p>Function: Endpoint to create a new Claim Offer based on an existing Claim Schema.</p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, and the schema <code>id</code>, namely the identifier of the Schema of the Claim intended to offer, as Path Parameters. </p> <p>Furthermore, It requires passing the following as Request Body parameters:</p> <ul> <li> <p><code>attributes</code> (required) an array of maximum two objects that describe the attributes of the Claim Offer. It's important that the number of objects matches the number of attributes defined inside the Schema Creation. Each object contains: attribute key` (required), name of the attribute as defined in the Schema</p> <ul> <li><code>attributeValue</code> (required), value to be assigned to that attribute; its type must match the type defined inside the Schema Creation;</li> </ul> </li> <li> <p><code>expirationDate</code>, a string that defines the expirationDate of the claim. It is a required value if you specified mandatoryExpiration as true in the Schema Creation.</p> </li> <li><code>limitedClaims</code>, a number that can be optionally set to define a limit to the amount of claim, based on this offer, that can be redeemed.</li> <li><code>claimLinkExpiration</code>, expiration date in ISO 8601 format for the Claim Offer Link. After that Date a Claim Offer will not be redeemable anymore using that Link.</li> </ul> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains a set of information related to your newly created Claim Offer such as its <code>id</code>.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/offers/apis/#get-offers-by-schema","title":"Get Offers By Schema","text":"<p>Function: Endpoint to fetch all the Claim Offers created for an existing Schema.</p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, and the schema <code>id</code>, namely the identifier of the existing Schema you are querying, as Path Parameters. </p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains an array of Objects where each object contains the details of a Claim Offer generated by a specific Issuer using the queried Schema.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/#get-offers-by-issuer","title":"Get Offers By Issuer","text":"<p>Function: Endpoint to fetch all the Claim Offers created by an Issuer.</p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, as Path Parameter. Optionally, it accepts a <code>query</code> as Query Parameter which is a search keyword. </p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains an array of Objects where each object contains the details of a Claim Offer generated by the queried Issuer.</p> <p>Compared to the <code>Get Offers By Schema</code> endpoint, this endpoint doesn't require to specify the <code>id</code> of a specific schema therefore the Response can contain offers based on different Schemas. </p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/#get-offer","title":"Get Offer","text":"<p>Function: Endpoint to fetch a specific Claim Offer.</p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, and the schema <code>id</code>, namely the identifier of the Schema used to create the Claim Offer, and the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you are querying, as Path Parameters.</p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>The Response Body contains an Object with the details of that specific Claim Offer.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/#update-offer","title":"Update Offer","text":"<p>Function: Endpoint to update a specific Claim Offer. </p> <p>How it works: It requires passing the Issuer <code>id</code>, namely the identifier of the Issuer previously created, and the schema <code>id</code>, namely the identifier of the Schema used to create the Claim Offer, and the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you want to delete, as Path Parameters.</p> <p>Furthermore, It requires passing a boolean for <code>active</code> as Request Body parameter: setting active to true will activate an Offer, setting active to false will deactivate an Offer.</p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. As a result of this Request, the Claim Offer, identifier by its <code>id</code>, gets deactivated. It means that you will no longer be able to <code>Create QRCode of Offer</code> based on that offer.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/offers/apis/#create-qrcode-of-offer","title":"Create QRCode of Offer","text":"<p>Function: Endpoint to generate a QR Code based on a specific Claim Offer for User Authentication.</p> <p>How it works: It requires passing the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you want to generate the QR Code for, as Path Parameter.</p> <p>The Response Body contains a set of details about the Claim Offer including the <code>qrCode</code>. The JSON file included in the <code>qrCode</code> can be parsed into a QR Code and presented to the user in order to authenticate. This endpoint will also create a specific <code>sessionID</code> for the user that is going to scan that QR Code.</p> <p>In order to execute this endpoint correctly it is necessary that: </p> <ul> <li>The Claim Offer is active (namely, it hasn't been deactivated using Delete Offer)</li> <li>The Claim Offer hasn't expired (namely, the <code>expirationDate</code> set in Offer Creation hasn't passed)</li> <li>The Claim Offer hasn't exceeded the limit (namely, the <code>limitedClaims</code> set in Offer Creation hasn't been exceeded)</li> </ul> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/offers/apis/#download-qrcode-of-offer","title":"Download QRCode of Offer","text":"<p>Function: Endpoint to download the QR Code based on a Claim Offer.</p> <p>How it works: The Endpoint requires passing the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you want to generate the QR Code for, as Path Parameter and the <code>sessionID</code> of the specific user that has been previously authenticated, as Query Parameter.</p> <p>On successful Request, the Response contains the actual QR Code to be displayed to the user in order to fetch a claim inside their Wallet.</p> <p>This endpoint downloads the same <code>qrCode</code> returned from the previous Endpoint as PNG Format.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/offers/apis/#get-qrcode-of-offer","title":"Get QRCode of Offer","text":"<p>Function: Returns the status of the scan of the QR Code. </p> <p>How it works: The Endpoint requires passing the claim offer <code>id</code>, namely the identifier of the specific Claim Offer you used to generate the QR Code, as Path Parameter and the <code>sessionID</code> generated on QR Code Creation, as Query Parameter.</p> <p>The Response Body contains the status of the scan of the first QR Code: - <code>pending</code> if it hasn't been scanned the status is pending - <code>error</code> if there's been an error in the process - <code>success</code> if the authorization was successful. In this case, it will also return a JSON file inside the <code>qrCode</code> field. </p> <p>The JSON File can be parsed into a QR Code and presented to the user in order to fetch a claim inside their Wallet.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/","title":"Onboarding Orgs","text":"<p>The Onboarding Orgs endpoints contain all the actions needed to manage an Organization Account, such as Creating an Account, Activating an Account, Sign-in to an Account or Resetting its password.</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#create-org","title":"Create Org","text":"<p>Function: Endpoint to create a new Account for an Organization. </p> <p>How it works: It requires passing <code>email</code> and <code>password</code> as required Request Body parameters. These represent the login credentials for your Organization. The Response Body contains a set of information related to your Organization Account such as its identifier <code>id</code>. </p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#sign-in","title":"Sign in","text":"<p>Function: Endpoint to sign-in to your Organization Account.</p> <p>How it works: It requires passing your Organization Account credentials <code>email</code> and <code>password</code> as required Request Body parameters. The Response Body contains a JWT token that will be used as <code>Bearer Token</code> in order to use other Endpoints. The token, if not deactivated or refreshed, will be active for 24 hours.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#activate-account","title":"Activate Account","text":"<p>Function: Endpoint to activate your Organization Account. </p> <p>How it works: It requires passing a valid <code>Bearer Token</code> token inside the Authorization Request Header. The Response Body contains an updated <code>Bearer Token</code>.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#resend-email","title":"Resend Email","text":"<p>Function: Endpoint to request an email that contains a link to activate your Organization Account.</p> <p>How it works: It requires passing your organization <code>email</code> as required Request Body parameters. As a result of this Request you will receive an email containing a link to activate your Organization Account.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#update-account","title":"Update Account","text":"<p>Function: Endpoint to update the password of your Organization Account.</p> <p>How it works: The Endpoint requires passing the Organization Account <code>id</code> as Path Parameter (you retrieve it as Response from the Create Org Endpoint) and the current password (<code>password</code>) and the new password <code>newPassword</code> as required Request Body parameters. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the updated set of information related to your Organization Account. </p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#request-reset-password","title":"Request Reset Password","text":"<p>Function: Endpoint to request for a link to reset a new password for your Organziation Account. </p> <p>How it works: It requires passing your Organization Account <code>email</code> as required Request Body parameters. As a result of this Request you will receive an email containing a link to Reset your Organization Account password.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#reset-password","title":"Reset Password","text":"<p>Function: Endpoint to set a new password for your Organziation Account. </p> <p>How it works: It requires passing the new <code>password</code> as required Request Body parameters. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. As a result of this Request you will change the password used to sign-in to your Organization Account.</p> <p>API Reference</p> <p></p> <p>The Reset Password Endpoint requires to be already sign-in to an Organization Account while the Request Reset Password doesn't. You will likely use the latter only when you forget your password!</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#update-account-email","title":"Update Account Email","text":"<p>Function: Endpoint to update the account email associated to your Organziation Account. </p> <p>How it works: It requires passing the <code>password</code> associated to your Organization Account and the new <code>email</code> that you want to associate to your Organization Account. The Endpoint requires passing a valid <code>Bearer Token</code>inside the Authorization Request Header. As a result of this Request a confirmation notification will be sent to the old account email with a deeplink to accept the change.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#refresh-token","title":"Refresh Token","text":"<p>Function: Endpoint to refresh the Bearer Token for an Organization Account. </p> <p>How it works: It requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains a refreshed <code>Bearer Token</code>.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/onboarding-orgs/apis/#sign-out","title":"Sign Out","text":"<p>Function: Endpoint to sign-out to your Organization Account.</p> <p>How it works: It requires passing an active <code>Bearer Token</code> inside the Authorization Request Header. As a result of this Request your Bearer Token will be deactivated.</p> <p>This action has to be performed every time you intend to deactive the Bearer Token.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/schemas/apis/","title":"Schemas","text":"<p>The Schemas APIs allow the creation of customized Schema for your Claims. A Claim Schema encodes the structure of a particular claim by defining the usage and the vocabulary of its Attributes. To achieve claim reusability across multiple verifiers is important to consistently use the same schema to represent the same type of information. As a rule of thumb, existing claim schemas should always be preferred in order to achieve interoperability inside the Polygon ID ecosystem.</p>"},{"location":"issuer/platform-api/schemas/apis/#create-schema","title":"Create Schema","text":"<p>Function: Endpoint to create a new Claim Schema Template for an Issuer</p> <p>How it works: The Endpoint requires passing the Issuer <code>id</code> as Path Parameter. </p> <p>It requires passing the following as Request Body parameters:</p> <ul> <li><code>schema</code> (required), name of the schema in a human-readable</li> <li><code>mandatoryExpiration</code> (required), a boolean that indicates whether to make the claim with mandatory expiration or not</li> <li><code>technicalName</code> (required), name of the schema with formatting constraints, such as no special characters and spaces</li> <li> <p><code>attributes</code> (required) an array of maximum two objects that describe the type of data stored inside the Claim Schema. Each object contains: </p> <ul> <li><code>name</code> (required), name of the attribute in a human-readable</li> <li><code>technicalName</code> (required), name of the attribute with formatting constraints, such as no special characters and spaces</li> <li><code>type</code> (required), type of the attribute which can be <code>boolean</code>, <code>date</code>, <code>datetime</code>, <code>multichoice</code> and <code>number</code>.</li> <li><code>description</code>, a string that may add further details about the Schema or describes the vocabulary used to define the attributes</li> <li><code>values</code>, an array of strings that represent the range of possible values that the attribute can cover in the case the chosen type is <code>multichoice</code>. There should be at least 2 values, while there's no upper limit</li> </ul> </li> </ul> <p>\u26a0\ufe0f The <code>multichoice</code> type is not supported yet from the Polygon ID Wallet</p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains a set of information related to your newly created Schemas such as its <code>id</code>.</p> <p>Remember that the Schema is only a Template which will be filled with actual user data inside the Claim Offer.</p> <p>API Reference</p> <p></p> <p>The usage of this endpoint is included in our full-flow Tutorial</p>"},{"location":"issuer/platform-api/schemas/apis/#get-schema","title":"Get Schema","text":"<p>Function: Endpoint to fetch the details of a specific Claim Schema starting from its <code>id</code>.</p> <p>How it works: It requires passing your Issuer <code>id</code> and the Schema <code>id</code> as Path Parameters. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the entire set of information related to the required Claim Schema.</p> <p>You can query a Schema created by a different Issuer. In order to do that you just need to pass the identifier of the queried Schema. The issuer identifier passed as Path Parameter must be your one!</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/schemas/apis/#get-all-schemas","title":"Get All Schemas","text":"<p>Function: Endpoint to fetch the details of all the Claim Schemas created by an Issuer.</p> <p>How it works: It requires passing the Issuer <code>id</code> as Path Parameter. Optionally, it accepts a <code>query</code> and a boolean <code>active</code> as Query Parameters which are search keywords. </p> <p>It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header. The Response Body contains the entire set of information related to the required Claim Schema.</p> <p>The Endpoint requires passing the Issuer <code>id</code> as Path Parameter. In order to use this endpoint, you need passing an active <code>Bearer Token</code> token inside the Authorization Request Header. The Response Body contains the entire set of information related to the Claim Schemas created by that specific Issuer. If the query was set to a specific value, for example <code>query=role</code> the Reponse Body will contain only the Schemas that contain the given keyword either in the schema Name or across its Attributes.</p> <p>API Reference</p> <p></p>"},{"location":"issuer/platform-api/schemas/apis/#get-schema-claims","title":"Get Schema Claims","text":"<p>Function: Endpoint to return all the Claims issued based on a particular Schema.</p> <p>How it works: It requires passing the Issuer <code>id</code> and the Schema <code>id</code> of the queried Schema as Path Parameters. It also requires passing a valid <code>Bearer Token</code> inside the Authorization Request Header.</p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/getting-started-flow/","title":"Getting Started -  Full Flow Tutorial","text":"<p>This flow details the steps that can be carried out to achieve full integration of the Issuer Node with the Polygon ID APIs.</p>"},{"location":"issuer-node/getting-started-flow/#steps-of-flow","title":"Steps of Flow","text":"<ol> <li>Setup the Issuer Node</li> <li>Create an Identity</li> <li>Create Credential </li> <li>Create a QR Code to Accept Credential</li> </ol>"},{"location":"issuer-node/getting-started-flow/#setup-the-issuer-node","title":"Setup the Issuer Node","text":"<p>The Issuer Node can be set up in two ways: using Docker or in the Standalone Mode. If you are using the M1/M2 chip on your Mac, it is advised to run it using the Standalone Mode.</p>"},{"location":"issuer-node/getting-started-flow/#start-issuer-node-using-docker-compose","title":"Start Issuer Node Using Docker-Compose","text":"<ol> <li> <p>Clone the Issuer Node repository from here</p> </li> <li> <p>Start Docker Daemon </p> </li> <li> <p>From inside your repository use the following command to run the Vault, Redis, And Postgres containers. </p> <pre><code>make up\n</code></pre> <p>With this, the system runs a <code>docker-compose</code> command to start the redis, postgres, and vault containers:</p> <pre><code>docker-compose -p \u201cproject name\u201d -f path/docker-compose.yml up -d redis postgres vault\n</code></pre> <p>where the <code>path</code> shows the location of the docker-compose.yml file.</p> <p>This starts the Postgres, Redis, and Vault containers:  </p> <p>To verify that the containers are running, execute this command:</p> <p><pre><code>docker ps\n</code></pre>   This lets you see all the containers that are currently running along with their statuses and ports.</p> <p> </p> <p>Note: Use these docker images only for evaluation purposes. For production, you must secure each of these services first. </p> </li> <li> <p>Add Ethereum Private Key to the Vault. For this, run the following command to start the vault container in the interactive mode. This command is used to go inside the vault and run <code>sh</code> or <code>bsh</code> commands inside it. </p> <pre><code>docker exec -it sh-id-platform-test-vault sh\n</code></pre> <p>As you run this command, it waits for your input. Here, as an input,  we shall place the <code>Ethereum Private Key</code> in the vault:</p> <pre><code>vault write iden3/import/pbkey key_type=ethereum private_key=&lt;privkey&gt;\n</code></pre> <p> </p> <p>With this, the Ethereum Private Key is written into the vault container. </p> </li> <li> <p>To set up your Issuer Node and make it all up and running, you need to configure it first. This is done using a <code>config.toml</code> file. The repository provides you with a <code>config.toml.sample</code> file that contains different fields and their sample values. To start configuring these fields, create a <code>config.toml</code> file in your repository and paste the contents of the <code>config.toml.sample</code> in it. A few fields need to be configured before you can start the Issuer Node.</p> <ul> <li> <p>ServerUrl:  If the Issuer Node is to be started locally, enter the localhost URL (for example, http://localhost:3001). If the Issuer Node is to be hosted on Google Cloud or an AWS or some other cloud (instead of being installed locally), enter the URL where the machine is located. Note: In order to communicate with the Polygon ID Wallet App, the Issuer Node must be hosted on a public URL. For a local setup, you can use ngrok to expose your local server to the internet.</p> </li> <li> <p>Keystore Token: It is the Initial Root Token of the Vault. Copy the value of this token from the Vault container and paste it here. OR, once you have run the docker containers, the token can be copied from this path in the repository: \"infrastructure/local/.vault/data/init.out\".  </p> </li> <li> <p>Ethereum URL: enter a valid JSON RPC URL for Polygon Mumbai. </p> </li> </ul> </li> <li> <p>Run the following command to start the Issuer Node:</p> <pre><code>make run\n</code></pre> <p>This starts the Issuer Node at the port specified in the <code>config.toml</code> file.     </p> </li> </ol>"},{"location":"issuer-node/getting-started-flow/#start-issuer-node-in-the-standalone-mode","title":"Start Issuer Node in the Standalone Mode","text":"<p>In the Standalone Mode, we compile the Issuer Node and create the executables to run it without using docker.</p> <ol> <li> <p>Clone the Issuer Node repository from here</p> </li> <li> <p>Run this command:</p> <p><pre><code>make build\n</code></pre> This command will compile and create binaries for <code>Platform</code> (for APIs), <code>Migrate</code> (for creating database schemas from scratch), and <code>Pending_Publisher</code>(which is a program that runs in the background and gets the failed transactions and retries them).</p> <p> </p> </li> <li> <p>Make sure that Vault, Redis, and Postgres are all up and running. You can use the <code>make up</code> command to start the containers (but as mentioned previously, use these images only for evaluation purposes):</p> <p><pre><code>make up\n</code></pre> </p> </li> <li> <p>Add Ethereum Private Key to the Vault; for this, follow step 4 of the previous section.</p> </li> <li> <p>Configure the <code>config.toml</code> file like you did in the previous section at step 5.</p> </li> <li> <p>Configure your database using the following command:</p> <p><pre><code>make db/migrate\n</code></pre> </p> <p>This checks the current structure of the database, and accordingly, either creates or updates the database. </p> </li> <li> <p>Run this command to start the Issuer Node:</p> <pre><code>./bin/platform\n</code></pre> <p> </p> <p>This starts the Issuer Node. You can now browse to the port configured for your server (ServerPort)in the <code>config.toml</code> file and view the API documentation. For example, this could be http://localhost:3001.</p> </li> <li> <p>Run the following command to start the Pending_Publisher service:</p> <pre><code>./bin/pending_publisher\n</code></pre> <p> </p> </li> </ol>"},{"location":"issuer-node/getting-started-flow/#authenticate-to-send-requests","title":"Authenticate to Send Requests","text":"<p>Before you can start making API calls to the Issuer Node with endpoints, you need to authenticate first with a <code>username</code> and a <code>password</code>. This is done using the Basic Auth endpoint using Postman or your own API platform. That usernmae and password are the ones that you have configured in the <code>config.toml</code> file.</p>"},{"location":"issuer-node/getting-started-flow/#create-identity","title":"Create Identity","text":"<p>Next, you need to create an Identity for the issuer/user. For this, make a call to the <code>Create Identity</code> endpoint. The <code>didMetaData</code> is passed in the request body. This metadata is required to create Issuer's DID.</p> <p><pre><code>{\n  \"didMetadata\": {\n    \"method\": \"polygonid\",\n    \"blockchain\": \"polygon\",\n    \"network\": \"mumbai\"\n  }\n}\n</code></pre> The Issuer Node responds by sending a response message that contains: <code>identifier</code> (Identifier of the Issuer) and the <code>identity state</code> (the state of the identity). This <code>identifier</code> would be used to create credentials as we would see in the next step. </p> <pre><code>{\n    \"identifier\": \"did:polygonid:polygon:mumbai:2qNDpfD8A2zjdiDbrzKsKe5XoP583FeBkpPyJnUEVx\",\n    \"state\": {\n        \"claimsTreeRoot\": \"96041fd8c899994d8b493c9f844f8ff17f1218e5400bfe68cc659b5386a88b07\",\n        \"createdAt\": \"2023-02-22T14:55:34.89165+05:30\",\n        \"modifiedAt\": \"2023-02-22T14:55:34.89165+05:30\",\n        \"state\": \"569bd6c053d6ddf463245127a82570841a76099a4dab3c279c6b461cf0438408\",\n        \"status\": \"confirmed\"\n    }\n}\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#create-credential","title":"Create Credential","text":"<p>Post Identity creation, you can start the process of credential creation. For this, the <code>Create Claim</code> endpoint is used. The <code>identifier</code> (or <code>id</code>) of the issuer you generated in the previous step is passed as path parameter in the request URL. <code>credentialSchema</code> (schema on which credential's format would be based) and <code>credentialSubject</code> (Subject details such as <code>id</code>(user's wallet id ), and other information related to the credential schema (for example, in this case, <code>birthday</code> and <code>documentType</code>) are passed in the request body. </p> <p><pre><code>{\n    \"credentialSchema\":\"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v3.json\",\n    \"type\": \"KYCAgeCredential\",\n    \"credentialSubject\": {\n        \"id\": \"{user's wallet did}\",\n        \"birthday\": 19960424,\n        \"documentType\": 2\n    },\n    \"expiration\": 12345\n}\n</code></pre> The Issuer Node responds by sending a credential id string. When this credential is later issued to the user, it gets stored in the user's wallet along with the credential's id string.</p> <pre><code>{\n    \"id\": \"9c08a414-b29c-11ed-9bd2-2e7e0e869740\"\n}\n</code></pre>"},{"location":"issuer-node/getting-started-flow/#create-qr-code-to-accept-a-credential","title":"Create QR Code to Accept a Credential","text":"<p>Note: In order to communicate with the Polygon ID Wallet App, the Issuer Node must be hosted on a public URL.</p> <p>With the <code>Get Claim QR Code</code> endpoint, you can generate a JSON which is then used to create a QR code. A user can use a third-party application to generate a QR Code from this JSON. </p> <p>The identifier <code>did</code> of the issuer that we generated with the <code>Create Identity</code> endpoint and Credential Id <code>cid</code> that we generated in the <code>Create Claim</code> endpoint are passed as the path parameters in the request URL. </p> <p>The Issuer Node responds by sending a JSON. </p> <pre><code>{\n    \"body\": {\n        \"credentials\": [\n            {\n                \"description\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld#KYCAgeCredential\",\n                \"id\": \"75d7ca20-b1ea-11ed-9bd2-2e7e0e869740\"\n            }\n        ],\n        \"url\": \"http://localhost:3001/v1/agent\"\n    },\n    \"from\": \"did:polygonid:polygon:mumbai:2qPUbMiYD8qFVjM6KLTY5qSMQpR9x6aSRfNByRkckm\",\n    \"id\": \"cf858ea9-ab66-4c3c-8c55-e99885b086e0\",\n    \"thid\": \"cf858ea9-ab66-4c3c-8c55-e99885b086e0\",\n    \"to\": \"did:polygonid:polygon:mumbai:2qNZRvFrnVfANm9UTJ3Wn3AP4wmy9CUvX1qpYE28up\",\n    \"typ\": \"application/iden3comm-plain-json\",\n    \"type\": \"https://iden3-communication.io/credentials/1.0/offer\"\n}\n</code></pre> <p>where <code>credentials</code> contains the credential id (<code>cid</code>) and the related schema link. </p> <p><code>url</code> is the address at which the user's wallet makes a call to the endpoint.</p> <p><code>from</code> is the <code>did</code> of the Issuer.</p> <p><code>to</code> is the <code>did</code> of the user's wallet.</p> <p><code>typ</code> and <code>type</code> indicate the way user's wallet interacts with the Node. </p> <p>Copy this JSON and paste it on a third-party website that can generate a QR code. </p> <p></p> <p>The user can scan this QR Code using the Polygon ID app and accept the credentials.</p> <p>This adds the credential to the user's wallet. </p> <p></p>"},{"location":"issuer-node/issuer-node-overview/","title":"Issuer Node Overview","text":"<p>The Issuer Node is a self-hosted Node that any implementer can quickly set up and integrate into their application. Once the setup is completed, the Issuer Node exposes all the functionalities necessary to run an issuer such as:</p> <ul> <li>Create, manage, and revoke an identity</li> <li>Issue credentials to an identity</li> <li>Share credentials with the user's wallet using QR Code</li> <li>Publish Identity States on-chain </li> <li>Revoke credentials </li> </ul> <p>The Issuer Node can generate multiple identities for multiple Issuers and manages the states of these identities by updating the state stored on-chain.</p> <p>The Issuer Node provides API endpoints for the integrator's applications.</p>"},{"location":"issuer-node/issuer-node-overview/#issuer-node-components","title":"Issuer Node Components","text":"<p>The Issuer Node comprises the following components and each one of these components can be either dockerized or each one of these can be launched as separate service. </p> <ul> <li> <p>Issuer Application to issue Verifiable Credentials and communicate with users' wallets.</p> </li> <li> <p>Vault: Based on HashiCorp, the Vault is used in the Issuer Node for providing key management services. It helps to secure sensitive data, such as the private key of the issuer, thus protecting them in a secure way. The Vault has been provided with a plugin called <code>vault-plugin-secrets-iden3</code>; this plugin is used to sign the data with Baby Jubjub Keys that are stored in the Vault. </p> </li> <li> <p>Redis: Redis is used for caching the schemas that we use in the Issuer Node. The schemas are downloaded from IPFS and stored on Redis. This way, every time, the Issuer Node issues a Credential, it doesn't need to fetch the schemas from an external source; it can fetch it directly from Redis. This boosts the performance of the application. </p> </li> <li> <p>DB: This container is used as the data source for the Issuer Node. In our implementation of the Issuer Node, we have used Postgres as the database. It is where all the data related to issued credentials are stored. </p> <p>Note: In a testing environment, you can run the Vault, Redis, and Postgres services inside a docker. But for production, you are advised to secure these services first before using them. </p> </li> </ul>"},{"location":"issuer-node/issuer-node-overview/#core-library","title":"Core Library","text":"<ul> <li>Issuer Node</li> </ul>"},{"location":"issuer-node/issuer-node-overview/#support-libraries","title":"Support Libraries","text":"<ul> <li>go Iden3 Core: Go implementation of iden3 core functionality  </li> <li>go Iden3 Crypto: Go implementation of important cryptographic elements including baby jubjub key, Keccak256, and poseidon </li> <li>go Merkle Tree SQL: Go implementation of Merkle tree based on the library of circuit templates</li> </ul>"},{"location":"issuer-node/issuer-node-api/introduction/","title":"Polygon ID Issuer Node APIs","text":"<p>The Issuer Node APIs provide a user with the following functionalities: </p> <ul> <li>Create and retrieve Identities</li> <li>Create a Verifiable Credential (VC)</li> <li>Retrieve a Verifiable Credential or a list of Verifiable Credentials</li> <li>Generate JSON to create a QR Code and use that to accept credentials in wallet</li> <li>Revoke a Verifiable Credential</li> <li>Retrieve the Revocation Status of a Verifiable Credential</li> <li>Call Agent Endpoint using the Wallet App</li> </ul> <p>These APIs can be tested locally on a Self Hosted Platform or with our Postman Collection. </p> <p>Note: Please note that the API endpoints listed in the testing links above need to be called in sequential order. For example, you need to first create an identity before a Verifiable Credential can be issued by the Issuer Node.</p>"},{"location":"issuer-node/issuer-node-api/agent/apis/","title":"Agent","text":"<p>The agent endpoint acts as a port to communicate messages between the mobile app and the server. The user, using the agent endpoint, can access the functionality through his/her mobile app. </p> <p>The core feature of  message-based communication initiation in messaging specification is the process of looking up the two main properties of each identity: </p> <ol> <li> <p>An endpoint (web, email, etc) where messages can be delivered to a specific identity. </p> </li> <li> <p>The public key that a specific identity agent is using for communication with another identity.</p> </li> </ol> <p>The JWZ is generated within the user's identity wallet in response to the authentication requested by an Issuer. </p>"},{"location":"issuer-node/issuer-node-api/agent/apis/#agent-endpoint","title":"Agent Endpoint","text":"<p>Function: Endpoint to send a JWZ token from the user's mobile app. </p> <p>How it Works: The user's app sends a JWZ token in the request body. </p> <p>The Issuer Node responds by sending a response message that contains details related to Verifiable Credential and Issuer. It also includes metadata such as:</p> <p><code>from</code>: from which user DID the message is sent <code>to</code>: to which Issuer DID the message is sent <code>id</code>: A random uuid generated for a transaction <code>threadID</code>: Part of the JWZ token <code>typ</code>: The way of communication between protocol and mobile  <code>type</code>: The way of communication between protocol and mobile </p> <p>A typical response looks like this:</p> <pre><code>{\n\"body\": {\n\"credential\": {\n\"id\": \"https://ce98-2a0c-5a84-3403-bb00-e0d9-c19e-2ab1-2a2b.eu.ngrok.io/issuer/v1/did:polygonid:polygon:mumbai:2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA/claims/ec81d686-a6e4-11ed-a1f4-debe37e1cbd5\",\n\"@context\": [\n\"https://www.w3.org/2018/credentials/v1\",\n\"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/iden3credential-v2.json-ld\",\n\"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\"\n],\n\"type\": [\n\"VerifiableCredential\",\n\"KYCAgeCredential\"\n],\n\"expirationDate\": \"2030-01-01T01:00:00+01:00\",\n\"issuanceDate\": \"2023-02-07T13:42:46.904238+01:00\",\n\"credentialSubject\": {\n\"birthday\": 19960424,\n\"documentType\": 782222,\n\"id\": \"did:polygonid:polygon:mumbai:2qG9d1nUyeTVU63vU1gH3jcD6Y8z4ANPSdFdQHPY4t\",\n\"type\": \"KYCAgeCredential\"\n},\n\"credentialStatus\": {\n\"id\": \"https://ce98-2a0c-5a84-3403-bb00-e0d9-c19e-2ab1-2a2b.eu.ngrok.io/issuer/v1/did%3Apolygonid%3Apolygon%3Amumbai%3A2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA/claims/revocation/status/4144415042\",\n\"revocationNonce\": 4144415042,\n\"type\": \"SparseMerkleTreeProof\"\n},\n\"issuer\": \"did:polygonid:polygon:mumbai:2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA\",\n\"credentialSchema\": {\n\"id\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v3.json\",\n\"type\": \"JsonSchemaValidator2018\"\n},\n\"proof\": [\n{\n\"type\": \"BJJSignature2021\",\n\"issuerData\": {\n\"id\": \"did:polygonid:polygon:mumbai:2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA\",\n\"state\": {\n\"claimsTreeRoot\": \"c244e9c4a42a1fb6aace041c08ecdc9532170194dd03ae99ffd5a035a4423f04\",\n\"value\": \"f92376a5ec15d599f877504d55a3c703d8e40aebb9e9e60802fc217a86693a02\"\n},\n\"authCoreClaim\": \"cca3371a6cb1b715004407e325bd993c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f8f439351d6704039b792e9ee4c6dc0a82f514ecb6e49f00350c4d1d4bbce2fe11274a4e0b1f374124cf775503a100922c59c8778c778b8b80614dfd52fad060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n\"mtp\": {\n\"existence\": true,\n\"siblings\": []\n},\n\"credentialStatus\": {\n\"id\": \"https://ce98-2a0c-5a84-3403-bb00-e0d9-c19e-2ab1-2a2b.eu.ngrok.io/issuer/v1/did%3Apolygonid%3Apolygon%3Amumbai%3A2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA/claims/revocation/status/0\",\n\"revocationNonce\": 0,\n\"type\": \"SparseMerkleTreeProof\"\n}\n},\n\"coreClaim\": \"c9b2370371b7fa8b3dab2a5ba81b68382a0000000000000000000000000000000212511ab3cc09f0f233e2868d41ae6f7bb2ac9d2dd791d75a99072f128c0d00de72a95dd264a4de5df8ce745c1d393c1480248d27e12f6f0f1ea6b5f12a722e000000000000000000000000000000000000000000000000000000000000000042c106f70000000080d8db700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n\"signature\": \"78aa6364e769c74557f63ffa6830271b213854ce1f75ad633822fb461fb8e2891ac19621958d27e2ea7997d9f9bcf8e713e97dc98cd3b4faaa71df5b55088303\"\n}\n]\n}\n},\n\"from\": \"did:polygonid:polygon:mumbai:2qDTZaJRKmLk9AiGkqwJePy2SWm1PtffGRF5CjTeZA\",\n\"id\": \"558984b4-b074-42a7-b60f-c2b5290d1a32\",\n\"threadID\": \"4ccb5b86-bf30-47a4-b7e1-e0e2e4edec8b\",\n\"to\": \"did:polygonid:polygon:mumbai:2qG9d1nUyeTVU63vU1gH3jcD6Y8z4ANPSdFdQHPY4t\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/credentials/1.0/issuance-response\"\n}\n</code></pre> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/","title":"Claim","text":"<p>The collection of Claim endpoints is used to provide the following set of functionalities:</p> <ul> <li>Create a Verifiable Credential (VC)</li> <li>Retrieve a credential or a set of credentials</li> <li>Generate a JSON to create a QR code </li> <li>Update Identity State</li> <li>Revoke a Verifiable Credential</li> <li>Retrieve Revocation Status</li> </ul> <p>An id (also called credential id) is assigned to a Verifiable Credential when it is created by an Issuer. A user can then retrieve a VC via its id. If a credential is no longer valid or lost, it can be revoked (rendered inactive and cannot be used). </p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#create-claim","title":"Create Claim","text":"<p>Function: Endpoint to create a Verifiable Credential for a user. </p> <p>How it Works: The DID (identifier string retrieved from calling the <code>Create Identity</code> endpoint) is passed as a path variable in the request URL. </p> <p>The following parameters are passed in the body of the request:</p> <ul> <li><code>credentialSchema</code>: It is a template for a Verifiable Credential that guarantees the structure of a credential. This way, an Issuer, a Holder, and a Verifier can reference the data in a known way. Further details on the <code>credentialSchema</code> can be found in the Create Custom Schema section.</li> <li><code>type</code>: the type of the credential schema sent.</li> <li><code>credentialSubject</code>: Contains DID (Decentralized Identifier), i.e. <code>did</code>, of the user and the fields related to the data to be attested.</li> <li><code>expiration</code>: Date of expiry of the Verifiable Credential. </li> </ul> <p>Note: Depending on the schema a user opts for, the request body may contain some fields of the schema while leaving out the others. For example, in the API reference, we have considered the schema of the type <code>KYCAgeCredential</code> and therefore, included the <code>birthday</code> and <code>documentType</code> fields. </p> <p>The Issuer Node responds by sending a response message that contains the string <code>id</code>, which is the id of the Verifiable Credential created by the Issuer Node. </p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#get-claim","title":"Get Claim","text":"<p>Function: Endpoint to retrieve a Verifiable Credential based on its Claim ID (CID). This way, you can retrieve a credential issued by an Issuer based on this credential's id. </p> <p>How it Works: The DID (the identifier string retrieved from calling the <code>Create Identity</code> endpoint) and the Claim ID, i.e.<code>id</code> (or CID) of the Verifiable Credential (retrieved from calling the <code>Create Claim</code> endpoint) are passed as path variables in the request URL. </p> <p>The endpoint requires to pass the issuer <code>did</code> and the Verifiable Credential <code>CID</code> as path variables in the request URL.</p> <p>The server responds by sending the following data about the Verifiable Credential:</p> <ul> <li> <p><code>Context</code>: URL pointing to the JSON-LD Context of the Verifiable Credential.</p> </li> <li> <p><code>credentialSchema</code>: URL pointing to the credential JSON schema. </p> </li> <li> <p><code>credentialStatus</code>: Shows the URL to fetch the Revocation status of the credential, <code>revocationNonce</code> (zero or any value), <code>type</code> (type of Proof, for example, SparseMerkleTreeProof). </p> </li> <li> <p><code>credentialSubject</code>: Contains details of the subject (to whom the credential is issued) and includes:</p> <ul> <li>Credential Fields (for example, <code>birthday</code> and <code>documentType</code> in the case of KYCAgeCredential)</li> <li><code>id</code>: DID of the Subject</li> <li><code>type</code>: Type of credential for credentialSubject (for example, KYCAgeCredential)</li> </ul> </li> <li> <p><code>id</code>: It is the id of the Verifiable Credential.</p> </li> <li> <p><code>expiration</code>: The date on which the credential shall expire.</p> </li> <li> <p><code>issuer</code>: DID of the Issuer.</p> </li> <li> <p><code>issuanceDate</code>: The date on which the credential was issued by the Issuer.</p> </li> <li> <p><code>proof</code>: The proof that the user creates to prove that s/he is the real owner of the Verifiable Credential issued from the Issuer and that the Verifiable Credential that it holds is valid. It includes:</p> <ul> <li><code>type</code> of proof (for example, BJJSignature2021 or SparseMerkleTreeProof)</li> <li><code>issuerData</code>: It includes the Issuer's <code>id</code> (DID of the Issuer) and its <code>state</code> (value of its claimstreeroot, i.e. root of the claims (credential) tree)</li> <li><code>authclaim</code>: Value of authclaim along with its mtp <code>existence</code> (proof of its existence/non-existence in the Merkle tree) - <code>coreclaim</code>: Value of coreclaim along with <code>signature</code> (Issuer's signature which verifies that the credential is issued by a valid Issuer). </li> </ul> </li> </ul> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#get-claims","title":"Get Claims","text":"<p>Function: Endpoint to retrieve all the Verifiable Credentials issued by an Issuer. </p> <p>How it Works: The DID (the identifier string retrieved from calling the <code>Create Identity</code> endpoint) is passed as path variables in the request URL. </p> <p>You can retrieve a set of credentials based on different filters or criteria. These criteria can be added as the query-string parameters in the request URL. These filters (and their data types) are listed below:</p> <ul> <li> <p>schemaType String: Type of schema. For example, schema based on Age-based KYC (KYCAgeCredential)</p> </li> <li> <p>schemaHash String: Hash of the schema. For example, c9b2370371b7fa8b3dab2a5ba81b6838</p> </li> <li> <p>subject String: Identifier of the Subject for which credentials are to be retrieved. For example, did:polygonid:polygon:mumbai:2qE1BZ7gcmEoP2KppvFPCZqyzyb5tK9T6Gec5HFANQ</p> </li> <li> <p>revoked Boolean: If the credential is revoked or not. It can be \"true\" or \"false\". </p> </li> <li> <p>self Boolean: Retrieve credentials of the provided Identifier. It can be \"true\" or \"false\". </p> </li> <li> <p>query-field String: Retrieve credentials based on the filters applied to the data of the credential. </p> </li> </ul> <p>Note: The \"subject\" and \"self\" filters cannot be applied together. </p> <p>The Issuer Node responds by sending a response message that contains the Verifiable Credential and all the information related to it. The response consists of information related to authclaim (which authorizes the user that requests for credential) and coreclaim (the actual credential issued by an Issuer to the user. Depending on these two claims, the information related to these two may differ in the response body. Here, we are going to provide an overview of some of these fields:</p> <ul> <li> <p><code>Context</code>: URL pointing to the json-ld documents that define how credential schema (here we are using BJJAuthCredential) and claim-schema-vocab (here we are using SparseMerkleTreeProof)are defined. </p> </li> <li> <p><code>credentialSchema</code>: URL pointing to the credential schema of type json. It could be a schema for <code>authclaim</code> or <code>coreclaim</code>.</p> </li> <li> <p><code>credentialStatus</code>: Shows credentialStatus <code>id</code> (which is the Revocation status of the credential (presence or absence of the revocation nonce value), <code>revocationNonce</code> (zero or any value), <code>type</code>(type of Proof, for example, SparseMerkleTreeProof). </p> </li> <li> <p><code>credentialSubject</code>: contains details of the subject (to whom the credential is issued) and includes the subject's date of birth, claim id, documentType, and other details.</p> <ul> <li><code>type</code>: Type of credential for credentialSubject (AuthBJJCredential or KYCAgeCredential)</li> </ul> </li> <li> <p><code>id</code>: It is the id of the Verifiable Credential.</p> </li> <li> <p><code>expiration</code>: The date on which the credential shall expire.</p> </li> <li> <p><code>issuer</code>: DID of the Issuer.</p> </li> <li> <p><code>issuanceDate</code>: The date on which the credential was issued by the Issuer.</p> </li> <li> <p><code>proof</code>: The proof that the user creates to prove that s/he is the real owner of the Verifiable Credential issued from the Issuer and that the Verifiable Credential that it holds is valid. It includes:</p> <ul> <li><code>type</code> of proof (for example, BJJSignature2021 or SparseMerkleTreeProof)</li> <li><code>issuerData</code>: It includes the Issuer's <code>id</code> (DID of the Issuer) and its <code>state</code> (value of its claimstreeroot, i.e. root of the claims (credential) tree)</li> <li><code>authclaim</code>: Value of authclaim along with its mtp <code>existence</code> (proof of its existence/non-existence in the Merkle tree) </li> <li><code>coreclaim</code>: Value of coreclaim along with <code>signature</code> (Issuer's signature which verifies that the credential is issued by a valid Issuer). </li> </ul> </li> </ul> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#get-claim-qr-code","title":"Get Claim QR Code","text":"<p>Note: In order to communicate with the Polygon ID Wallet App, the Issuer Node must be hosted on a public URL.</p> <p>Function: Endpoint to generate a JSON which is then used to generate a QR code on a third-party app. The user can then scan this QR code and accept credentials to his/her wallet.  </p> <p>How it Works: The Issuer DID (identifier string retrieved from calling the <code>Create Identity</code> endpoint) and credential Identifier (or <code>cid</code> retrieved from the <code>Create Claim</code> endpoint) are passed as path variables in the request URL. </p> <p>The Issuer Node responds by sending a response message that contains a JSON which carries the following fields:</p> <p><code>credentials</code> contains the credential id (<code>cid</code>) and a link to the schema associated with the credential.</p> <p><code>url</code> is the address at which the user's wallet makes a call to the endpoint. </p> <p><code>from</code> is the <code>did</code> of the Issuer.</p> <p><code>to</code> is the <code>did</code> of the user's wallet.</p> <p><code>typ</code> and <code>type</code> indicate the way user's wallet interacts with the Node.</p> <p>This JSON can then be pasted on a third-party app's interface that supports generating QR codes. Once a QR code is generated, the user can scan it via Polygon ID app on mobile and accept a credential to his/her wallet. </p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#revoke-claim","title":"Revoke Claim","text":"<p>Function: Endpoint to revoke a Verifiable Credential </p> <p>How it Works: The Issuer DID (The identifier string retrieved from calling the <code>Create Identity</code> endpoint) and <code>nonce</code> of the VC to be revoked (Revocation Nonce) are passed as a path variable in the request URL. </p> <p>The server responds by showing the Revocation Status of the credential.</p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/claim/apis/#get-revocation-status","title":"Get Revocation Status","text":"<p>Function: Endpoint to retrieve the Revocation Status of the Verifiable Credential.  </p> <p>How it Works: The DID (The identifier string retrieved from calling the <code>Create Identity</code> endpoint) and <code>nonce</code> (Revocation Nonce) are passed as a path variable in the request URL. For the credential to be marked \"revoked\", we need to publish the state first on-chain, and then wait for 5 confirmation blocks. </p> <p>The server responds by sending the following details:</p> <ul> <li><code>issuer</code><ul> <li><code>claimstreeRoot</code>: Root of the Claims Merkle Tree of the Issuer</li> <li><code>state</code>: The Issuer's Identity State </li> </ul> </li> <li><code>mtp</code><ul> <li><code>existence</code>: Existence or Non-existence of the Revocation Nonce on the Revocation Merkle Tree. For retrieving the revocation status from this endpoint, we need to first send a transaction and after that, the state is published on-chain. Once that is done, the existence of the revocation nonce on Merkle Tree changes to \"true\".    </li> </ul> </li> </ul> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/identity/apis/","title":"Identity","text":"<p>The identity endpoint is used to create and retrieve identities for a user/issuer. Polygon ID supports the creation of identities the in form of DIDs (Decentralized Identifiers).</p> <p>Note: A DID is a cryptographically verifiable decentralized identifier. How a DID is verified is specified in its DID method. A DID resolves to a DID document that describes how to interact with the DID subject (The user that holds the identity). The DID document contains public keys that are used to authenticate the DID subject. An example of DID resolution could be a verifier resolving an Issuer's DID to get the public key, which is required to verify the signature on a Verifiable Credential. </p> <p>A DID can be represented as: <pre><code>did: did method: did method-specific identifier. \n</code></pre> This is a standard form of expressing a Decentralised Identifier as defined by the W3C DID Core 1.0 Specifications</p> <p>A user can have multiple DIDs. </p>"},{"location":"issuer-node/issuer-node-api/identity/apis/#create-identity","title":"Create Identity","text":"<p>Function: Endpoint to create an Identifier for a user/issuer. </p> <p>How it Works: The request to create an identity is sent to the Issuer Node. <code>didMetaData</code> is passed in the request body. This metadata is required to create Issuer's DID.</p> <p>An example of a <code>didMetaData</code> passed in the request body of the <code>Create Identity</code> endpoint is shown below:</p> <p><pre><code>{\n    \"didMetadata\":{\n        \"method\": \"polygonid\",\n        \"blockchain\":\"polygon\",\n        \"network\": \"mumbai\"\n    }\n}\n</code></pre> A few variations of the metadata can be:</p> <pre><code>method:\n    \"polygonid\"\n    \"iden3\"\n\nblockchain:\n    \"polygon\"\n    \"eth\"\n\nnetwork:\n    \"main\"\n    \"mumbai\"\n    \"goerli\"\n    \"unknown\"\n</code></pre> <p>The Issuer Node responds by sending a response message that contains:</p> <ul> <li><code>identifier</code>: Identifier of the Issuer in the standard DID format. For example:</li> </ul> <p><code>did:polygonid:polygon:mumbai:2qNBWSAsyvaGBpqQVHk3E4cgChaN6ogaZnYCQUyoRQ</code> </p> <ul> <li><code>identity state</code>: It is the state of the identity and contains fields that include <code>claimsTreeRoot</code> (Verifiable Credentials are added to the Claims Tree and its root is calculated), <code>state</code> (state of identity), and <code>status</code> (whether the status of the identity state is confirmed or pending. <code>identity state</code> also contains the timestamp when the identity was created (<code>createdAt</code>) or updated(<code>modifiedAt</code>). </li> </ul> <p>For each call to the <code>Create Identity</code>, a random Identifier is created. </p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/identity/apis/#get-identities","title":"Get Identities","text":"<p>Function: Endpoint to retrieve all the identities (identifiers) of a user.</p> <p>How it Works: The request to retrieve an identity is sent to the Issuer Node. <code>didMetaData</code> is passed in the request body. </p> <p>The Issuer Node responds by sending a response message that contains:</p> <ul> <li><code>identifier</code>: Identifier of the Issuer in the standard DID format. For example:</li> </ul> <p><code>did:polygonid:polygon:mumbai:2qNBWSAsyvaGBpqQVHk3E4cgChaN6ogaZnYCQUyoRQ</code></p> <p>API Reference</p> <p></p>"},{"location":"issuer-node/issuer-node-api/identity/apis/#publish-state-on-chain","title":"Publish State On-Chain","text":"<p>Function: Endpoint to publish the Identity State on-chain. </p> <p>How it Works: The identifier string in the DID format (retrieved from calling the <code>Create Identity</code> endpoint) is passed as a path variable in the request URL. </p> <p>The Issuer Node responds by sending a response message that indicates the published state of the Identity. If there is no state to publish, the Node shows the message as: \"no states to process\". If the state is published, the Node sends the following information:</p> <ul> <li> <p><code>claimsTreeRoot</code>: The root of the Claims Merkle Tree. For example, d9c1e213584c4e7f444bdc42a5cdbd038556d1455a8344e3a1451c346461a41d</p> </li> <li> <p><code>revocationTreeRoot</code>: The root of the Revocation Merkle Tree. For example, 0000000000000000000000000000000000000000000000000000000000000000</p> </li> <li> <p><code>rootOfRoots</code>: The root of the Roots Merkle Tree. For example,9b952dab35ed362f62573c7b1bb0ee1e5dcb32109fafacb24c9b335fbddf4f2e</p> </li> <li> <p><code>state</code>: The published state of the Identity. It is calculated by taking the roots of the Claims Tree, Revocation Tree, and Roots Tree. For example, a state could be: 1d9639360ad6e7fb86b8d2f55abd6201cae521e812496cd6606ce36a5829c316</p> </li> <li> <p><code>txID</code>: Transaction ID of the Published state on-chain. For example, 0xaed59e4195e73ee6c4278be1a5e01ecbdf2ff9565511916200dedda9bb20ff38</p> </li> </ul> <p>API Reference</p> <p></p>"},{"location":"js-sdk/js-sdk-overview/","title":"JS SDK Overview","text":"<p>The Polygon ID JS SDK is a Software Development Kit created in JavaScript. Based on the iden3 core protocol libraries, it is used for interacting with REST APIs and developing browser-based applications. </p> <p>With JS SDK, a user can create a browser extension that allows him/her to store the credentials and a key, and then the user can generate proofs of having those credentials. </p> <p>The Polygon ID JS SDK provides the developers intending to create a browser extension for the JS-based SDK. Using this SDK, these devs can start creating and issuing verifiable credentials (related to one's identity) based on our iden3 protocol. Individuals and organizations can use this extension for their browser-based applications. </p> <p>Note: With JS SDK, you can build custom applications/modules by applying your changes to our existing codebase. The functionalities that we provide in these tutorials can be extended as per your requirements. For example, JS SDK does not provide a codebase for database storage but you can implement that by extending SDK's functionality. </p>"},{"location":"js-sdk/js-sdk-overview/#why-js-sdk","title":"Why JS SDK?","text":"<p>The Polygon ID JS SDK has been developed to provide the following functionalities for a user's browser-based wallet:</p> <ul> <li>Create and manage Identity wallet</li> <li>Issue and manage credentials</li> <li>Generate zero-knowledge proofs after credential issuance</li> <li>Publish the updated state of the Issuer once a credential is added to the claims Merkle tree. </li> <li>Handle authorization requests</li> </ul>"},{"location":"js-sdk/js-sdk-overview/#components-of-js-sdk","title":"Components of JS SDK","text":"<p>The following components form the inherent part of the JS SDK:</p> <ul> <li>Identity Wallet</li> <li>Credential Wallet</li> <li>Iden3comm (Authentication Handler/Fetch Handler)</li> <li> <p>Proof Generation </p> <p>In the upcoming tutorials, we shall read more about the implementation of these components in JS SDK. To know what each of these components stands for, go through the following links: </p> </li> <li> <p>Identity Wallet</p> </li> <li> <p>Credential Wallet</p> </li> <li> <p>Iden3comm</p> </li> <li> <p>Proof</p> </li> </ul>"},{"location":"js-sdk/js-sdk-overview/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Node.js must be installed on your system. Version 16.14 or above is required for Polygon ID JS SDK.</p> <p>Note: While installing Node.js, make sure that you select all the checkboxes related to the dependencies. </p> </li> <li> <p>A browser where you can install and manage your browser wallet. </p> </li> </ul>"},{"location":"js-sdk/js-sdk-overview/#dependencies","title":"Dependencies","text":""},{"location":"js-sdk/js-sdk-overview/#core-libraries","title":"Core Libraries","text":"<p>JS SDK is a fully-functional wrapper on top of our iden3 core libraries. The following set of core iden3 libraries has been used to implement Polygon ID JS SDK:</p> <ul> <li> <p>Iden3 JS Crypto: Implementation of the Elliptic Curve for Baby Jubjub Key, Posedion hash and other cryptographic elements.</p> </li> <li> <p>JS Iden3 Core: JavaScript implementation of the iden3 core functionalities including Identity creation. </p> </li> <li> <p>JS JSON-LD Merklization: A library that merkelizes JSON-LD documents in JavaScript. Merklization is a process that creates a Merkle tree of a JSON-LD document so that it can be verified for its data integrity and authenticity. It is a library that lets you work with Verifiable Credentials. A JSON-LD is a schema document that represents data fields related to a Verifiable Credential in a pre-determined format. </p> </li> <li> <p>JS JWZ: JavaScript implementation of JSON Web Zero Knowledge and lets you create JWZ tokens. </p> </li> <li> <p>JS Merkle Tree: JavaScript implemnetation for creating a Sparse Merkle Tree (SMT). It carries code implenmentation for browser, local storage, and memory. </p> </li> </ul> <p>Follow the links mentioned below to know more about W3C stanadards for Verifiable Credentials and DID (Decentralised Identifier):</p> <ul> <li> <p>DID</p> </li> <li> <p>Verifiable Credentials</p> </li> </ul>"},{"location":"js-sdk/js-sdk-overview/#what-can-be-built-upon-js-sdk","title":"What Can Be Built Upon JS SDK?","text":"<p>On the Polygon ID JS SDK, you can build the following functionalities:</p> <ul> <li>An Issuer on a Merkle Tree</li> <li>A Verifier that can verify zero-knowledge proofs generated by a user's identity wallet</li> <li>An Identity Wallet based on the Iden3 core protocol</li> <li>The JS SDK also provides a revocation feature for credentials and proof generation</li> </ul>"},{"location":"js-sdk/identity/identity-wallet/","title":"Identity Wallet","text":"<p>An identity wallet holds the identity of the user and carries the following components:</p> <ul> <li> <p>Key Management Store (kms): It allows the user to sign data using keys and is the storage that is allocated to these keys.</p> </li> <li> <p>Data Storage Interface: It is an interface that allows you to communicate with Credential storage, Identity storage, Merkle tree storage, and State interfaces. This interface lets you create an identity for the user. </p> </li> <li> <p>Credential Wallet: It contains business logic on the top of the Credential storage. An Identity Wallet uses a Credential Wallet for mapping the credentials issued to an Identity. </p> </li> </ul> <p>The methods described below let you create and manage an identity wallet. </p>"},{"location":"js-sdk/identity/identity-wallet/#create-an-identity-using-createidentity","title":"Create an Identity using createIdentity()","text":"<p>This method creates an Auth Baby Jub Jub Credential(for signing on behalf of an identity) and an Identifier for an Identity. The Baby Jub Jub Key is the elliptic curve implementaion used in iden3.</p> <p>To create an Identity, first, the three Merkle trees, i.e. Claims tree, Revocation tree, and Roots of Root tree are created. Auth BJJ key is then added to the Claims tree. The hash of these three trees creates a root that is used to create an Identity State. The first state created is called the Genesis State and it is from this Genesis State that a unique Identifier ( in the DID format) is generated. </p> <p>The root of the three trees is used to create a Merkle Tree Proof (MTP)  which verifies the existence of a credential on the Merkle tree. </p> <pre><code> createIdentity(\n    hostUrl: string,\n    opts?: IdentityCreationOptions\n  ): Promise&lt;{ did: DID; credential: W3CCredential }&gt;;\n</code></pre> <p>where <code>hostUrl</code>is a part of the Identifier of Auth BJJ Credential. For example, let us assume that an Issuer Node has issued a credential. Then the <code>hostUrl</code> could be of the form:</p> <p>Issuer Node Address/Issuer Id/ Credential Id</p> <p>where Issuer Id is the identifier of the Issuer and Credential Id is the id of the credential issued by the Issuer Node.</p> <p><code>IdentityCreationOptions</code> lets you select the following options for creating an Identity:</p> <p><pre><code>export interface IdentityCreationOptions {\n  method: DidMethod;\n  blockchain: Blockchain;\n  networkId: NetworkId;\n  seed?: Uint8Array;\n  rhsUrl?: string;\n}\n</code></pre> where <code>method</code> is the type of <code>did</code> method used to create an identity, <code>seed</code> is a random/non-random number used to generate the BJJ key-pair, <code>rhsUrl</code> is the URL to reverse the hash so that the revocation status can be fetched from the Auth BJJ Credential. </p> <p>Note: <code>rhsUrl</code> is not a mandatory field but we encourage you to use it as it will ease the way you fetch the revocation status of the credential. Also, by providing <code>rhsUrl</code> value in the <code>IdentityCreationOptions</code>, it is possible to continue working in the browser.  If <code>rhsUrl</code> is not provided, we can use <code>hostUrl</code> to fetch the revocation status. </p> <p>The <code>createIdentity</code> method returns a <code>did</code> (Decentralised Identifier) in the DID format and a credential based on the w3c standard for a Verifiable Credential.  </p> <p>Note: It is worth noting that <code>did</code> is a Decentralized Identifier associated with an identity and enables verifiable identities. A <code>did</code> could be a person, thing, organization, or even an abstract entity. The controller of the <code>did</code> can prove that it is the real owner of the identity without the need of seeking permissions/approvals from any centralized authority. </p> <p>A <code>did</code> is expressed in the following format (as per w3.org standards):</p> <p>did: did method: did method-specific identifier</p> <p>Note: To know more on iden3 core elements (Baby Jub Jub Key, Credentials, and Identifiers, read our tutorials here</p>"},{"location":"js-sdk/identity/identity-wallet/#create-profiles-using-createprofile","title":"Create Profiles using createProfile()","text":"<p>This method creates profiles based on the genesis identifier. To keep the user's identity hidden from a Verifier, we can generate different profiles from his/her existing identifier. So, a user has the option to select a particular profile for a particular Verifier so that his real identity is not revealed. </p> <p><pre><code>createProfile(did: DID, nonce: number, verifier: string): Promise&lt;DID&gt;;\n</code></pre> where <code>did</code> is the DID from which a profile is generated. <code>nonce</code> is a unique integer used to generate a profile.  <code>verifier</code> is the verifier identity/alias in the string format. </p> <p>This method returns a profile id. </p>"},{"location":"js-sdk/identity/identity-wallet/#generate-key-using-generatekey-method","title":"Generate Key using generateKey() method","text":"<p>This method creates a new Baby Jubjub or EDCSA type of key. </p> <p><pre><code> generateKey(keyType: KmsKeyType): Promise&lt;KmsKeyId&gt;;\n</code></pre> where <code>keyType</code> is the type of key supported by the Key Management System.</p> <p>This method returns a <code>Promise&lt;KmsKeyId&gt;</code> which generates the key of the type mentioned in <code>keyType</code> parameter. </p>"},{"location":"js-sdk/identity/identity-wallet/#issue-credentials-using-issuecredential-method","title":"Issue Credentials using issueCredential() method","text":"<p>This method lets an Issuer issue a credential to a user as requested by the user.</p> <p><code>issueCredential(     issuerDID: DID,     req: CredentialRequest,     hostUrl: string,     opts?: CredentialIssueOptions   ): Promise&lt;W3CCredential&gt;;</code> where <code>issuerDID</code> is the identifier of the Issuer in the <code>did</code> format we described earlier.  <code>hostUrl</code> is part of the Credential id (added to it as a prefix). <code>CredentialIssueOptions</code> allows to use or not use <code>rhsUrl</code>(Url for getting the Reverse Hash service). </p> <p>This method returns a core claim which is then added to the Merkle tree and this claim is then transformed into a Verifiable Credential based on the w3c standards and issued to teh user. The core claim is signed by the Issuer and a BabyJubjub Signature Proof is also added to the credential.  </p> <p>## Create a Tree Model using getDIDTreeModel() method</p> <p>This method creates a tree model for a <code>did</code>; the model consists of a Claims tree, a Revocation tree, and a Roots of Root tree, and the identity hash of the state created from these trees. </p> <p><pre><code>getDIDTreeModel(did: DID): Promise&lt;TreesModel&gt;;\n</code></pre> where <code>did</code> is the DID of the </p> <p>This method returns a <code>Promise&lt;TreesModel&gt;</code> which returns the three Merkle trees from the database storage. </p>"},{"location":"js-sdk/identity/identity-wallet/#generate-merkle-tree-proof-using-generatecredentialmtp-method","title":"Generate Merkle Tree proof using generateCredentialMtp() Method","text":"<p>This method generates Merkle Tree Proof (MTP) for the inclusion or non-inclusion of a credential in the Claims tree by following the path from the leaf to the root in the given Merkle tree storage. To know more about the credential's inclusion in a Merkle tree, read our iden3 core specification tutorials here. </p> <p><pre><code>    generateCredentialMtp(\n    did: DID,\n    credential: W3CCredential,\n    treeState?: TreeState\n  ): Promise&lt;MerkleTreeProofWithTreeState&gt;;\n  ```\n\n where `did` is the DID of the Issuer that issued the credential to the user. \n\n `credential` is the Verifiable Credential (in the W3CC format) used to generate the MTP. \n `TreeState` is the tree's state used to generate the MTP. If we do not pass the `TreeState` parameter, the method considers the latest state of the Identity for creating MTP. \n\nThis method returns `MerkletTreeProof` along with the `TreeState` for which proof is generated. \n\n\n## Generate Non-Revocation Merkle Tree Proof using generateNonRevocationMtp() method\n\nThis method generates Merkle Tree Proof for the inclusion or non-inclusion of the revocation nonce of a credential in the Revocation Tree. \n\n&lt;!-- and its root or to the current root of the Revocation tree in the given Merkle tree storage.--&gt;\n</code></pre>   generateNonRevocationMtp(     did: DID,     credential: W3CCredential,     treeState?: TreeState   ): Promise; <pre><code>where `did` is the DID of the Issuer that issues the credential. \n`credential` is the Verifiable Credential (in the W3CC format) used to generate the Non-Revocation Merkle Tree Proof. \n`TreeState` is the tree's state used to generate the Non-Revocation MTP. If we do not pass the `TreeState` parameter, the method considers the latest state of the Identity for creating MTP. \n\nThis method returns `MerkletTreeProof` along with the `TreeState` for which proof is generated. \n\nTo know more about the Revocation of a credential, read [here](https://docs.iden3.io/getting-started/claim-revocation/). \n\n\n## Sign Credential Using Sign() Method\n\nThis method signs a payload of an arbitrary size with an Auth BJJ Credential, which contains a public key and a reference to the Key Management Store (where we store and fetch a private key for the credential).\n\n\n  ```\n  sign(payload: Uint8Array, credential: W3CCredential): Promise&lt;Signature&gt;;\n  ```\nwhere `payload` is any arbitrary string or an unsigned integer array.\n\n`credential` is Auth BJJ Credential in the W3CC format.\n\nThis method returns the signature object. &lt;!--with R8 and S parameters.--&gt; \n\n## Sign a Challenge using signChallenge() method\n\nThis method signs a big integer with the Auth BJJ Credential, which identifies a key for signing.\n</code></pre> signChallenge(payload: bigint, credential: W3CCredential): Promise; <pre><code>where `payload` is a big number (bigint). A big number is used in cryptography to prevent anyone from figuring them out.  \n\n`credential` is Auth BJJ Credential in the W3CC format.\n\nThis method returns the signature object. &lt;!--with R8 and S parameters.--&gt;  \n\n## Revoke Credential using revokeCredential() method\n\nThis method generates a Revocation Nonce for a credential that we need to revoke (or render invalid due to its expiry, loss, or any other reason).\n</code></pre> revokeCredential(issuerDID: DID, credential: W3CCredential): Promise; <pre><code>where &lt;!--issuerDID--&gt; is Issuer's identifier.\n`credential` is the W3CC Credential that needs to be revoked. \n\nThis method returns the Revocation Nonce of the credential. \n\n## Generate Iden3 Sparse Merkle Tree Proof using generateIden3SparseMerkleTreeProof() Method\n\nThis method generates the Iden3 SparseMerkleTree (SMTP) proof that an Issuer state of a specific credential is included in the Merkle Tree or not.\n\nWith the IssueCredential() method, a Credential is generated along with the Signature Proof. This credential is then added to the Claims Merkle tree and therefore, the state of the tree gets changed. For this, another proof called SMTP is required. This proof generates the changed state of the tree by taking Issuer DID, transaction data, and the list of credentials that are part of the changed state as the input parameters.  The JS SDK updates the credential with this SMT Proof, which is included in the state, the transaction data, and the Issuer.\n</code></pre> generateIden3SparseMerkleTreeProof(     issuerDID: DID,     credentials: W3CCredential[],     txId: string,     blockNumber?: number,     blockTimestamp?: number   ): Promise; <pre><code>where &lt;issuerDID&gt; is Issuer's identifier.\n\n`credential` is the list of Verifiable Credentials required to generate the proof. \n\n`txId` is a hash of the transaction for which state transition is done. \n\n`blockNumber` is the number of the block in which state transition has been done.\n\n`blockTimestamp` is the timestamp of the block at which the state transition has been done.\n\nThis method returns a list of credentials along with a Sparse Merkle Tree Proof. \n\n\n## Publish State to Reverse Hash Service with publishStateToRHS() Method\n\nFor a self-hosted Issuer with a set of APIs, we can use hostUrl as a way to fetch the revocation status of a credential. But if we are using a browser, we need to fetch the revocation status via rhsURL (Reverse Hash Service URL) by pushing the state update to this URL. \n\nThe `publishStateRHS` method publishes the updated state of the tree to the Reverse HAsh Service. \n</code></pre> publishStateToRHS(issuerDID: DID, rhsURL: string, revokedNonces?: number[]): Promise; <pre><code>where `issuerDID` is the `did` of the Issuer\n`rhsURL` is the REverse Hash Service URL.\n`revokedNonces` are the nonces of the revoked credentials. \n\n\n\n## Get Core Claim Representation with getCoreClaimFromCredential() Method\n\nThis method extracts the core claim from either the Signature proof or the Merkle Tree Proof. If we have both types of proofs for the credential, this method extracts the core representation from the Merkle Tree Proof. \n</code></pre> getCoreClaimFromCredential(credential: W3CCredential): Promise; ``` <p>where <code>credential</code> is the Verifiable Credential in the W3CC format that is usd to extract the core representaion of the claim. </p> <p>The method returns the core claim representation of the credential. </p>"},{"location":"verifier/demo-verifier/","title":"Demo Verifier","text":"<p>The Demo Verifier is a playground that allows you to create query based on a specific credential, generate QR based on that query and let the user scan the QR code to generate a zero-knowledge proof that the query is satisfied.</p>"},{"location":"verifier/demo-verifier/#prerequisites","title":"Prerequisites","text":"<p>Download the Polygon ID Wallet App and create an Identity.</p> <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> <li>Have the queried credential inside your wallet. For the tutorial, we are using the <code>ProofOfDaoLongevity</code> that can be created via the Demo Issuer.</li> </ul>"},{"location":"verifier/demo-verifier/#quick-start","title":"Quick Start","text":"<ol> <li> <p>On the Demo Verifier website click on the drop-down menu and, therefore Custom</p> <p> </p> <p>Then click on Sign In.</p> </li> <li> <p>Create the query via the editor.</p> <p>The editor allows you to design the query that the user will have to satisfy. The query is created by selecting the credential type and the attribute that you want to query. More info on how to design a query are described via the ZK Query Language.</p> <p>In this example, we are querying the date of entry of the user inside a DAO. In particular, we want to make sure that the user joined the DAO before a specific date. This query is based on the <code>ProofOfDaoLongevity</code> credential type described by this JSON-LD Context.</p> <p>Then click Submit.</p> <p> </p> </li> <li> <p>The query is then converted into a QR code that can be scanned by the user.</p> <p> </p> <p>Once scanning the QR code with the Polygon ID app, the user will be prompted to generate a zero knowledge proof that attests that the query is satisfied without revealing any further information about the credential. For example, the actual date of entry of the user inside the DAO is not revealed to the verifier.</p> </li> </ol>"},{"location":"verifier/verifier-overview/","title":"Verifier","text":"<p>A Verifier is any web2 or web3 platform that wants to authenticate users based on their Credentials.</p> <p>Verifiers can set up queries based on users\u2019 existing Credentials collected from a broad set of Issuers. A Query encapsulates the criteria that a user must match to authenticate, such as \u201cmust be a member of XYZ DAO\u201d or \u201cmust be over 18 years old\u201d. Polygon ID provides a seamless, customized and privacy-based authentication experience to users.</p> <p>The request of the Verifier is designed using our fully expressive zk Query Language and encapsulated into a QR code (or via deeplinking) to be shown to the user. The user scans the QR code with its Wallet to prompt the proof generation. </p> <p>The verification process doesn\u2019t involve any interaction between the Verifier and the Issuer of the requested credential. As part of the Query, the Verifier includes the identifiers of the trusted issuers. For example, a Verifier should add XYZ DAO as the only trusted Issuer when verifying that an individual is a member of XYZ DAO. XYZ DAO doesn\u2019t need to accept nor interact with the Verifier.</p> <p>At the end of the process the verifier gets a cryptographic proof that the user satisfies the query, while the user shares just the minimum possible amount of data required for the interaction.</p>"},{"location":"verifier/verifier-overview/#verifier-sdk","title":"Verifier SDK","text":"<p>The Verifier SDK is a set of tools that allow any application to verify user information based on their credentials. The SDK provides a fully customizable and privacy-based authentication experience to users.  The process of verifying user information based on their credentials can happen on-chain via a smart contract or off-chain. Both processes involve the same level of user privacy and the same degree of query customization. The proof generated on mobile is the same for both cases; the only difference is in the verification process. The on-chain verification happens programmatically inside a smart contract. The off-chain verification happens inside a script that needs to be setup by the Verifier application (either on a server or on the client side):</p> <ul> <li>Verifier SDK - Off-chain Verification provides all the elements to create a customized Query, set up a verifier and generate a QR code (or deeplink) on the client side to request proof from the user.</li> <li>Verifier SDK - On-chain Verification allows Dapps to verify users' credentials inside a Smart Contract using zero knowledge proof cryptography. </li> </ul>"},{"location":"verifier/verifier-overview/#quick-start","title":"Quick Start","text":"<p>You can quickly try out the Verification experience by following the steps below: </p> <ul> <li>Download the Polygon ID Wallet App and create an Identity. <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> </ul> </li> <li>Fetch a credential from the Demo Issuer</li> <li>Verify it on the Demo Verifier</li> </ul>"},{"location":"verifier/on-chain-verification/overview/","title":"On-chain ZK Verification","text":"<p>The on-chain verification workflow allows Dapps to verify users' credentials inside a Smart Contract. Zero-Knowledge Proof cryptography enables this verification to happen in a private manner, namely without revealing any personal information of the user (prover).</p> <p>This flow is especially needed when further on-chain logic wants to be implemented on successful verification such as:</p> <ul> <li>Distribute a token-airdrop only to human-verified accounts</li> <li>Allow voting only to account members of your DAO </li> <li>Block airdrops to users that belong to a specific country</li> <li>Allow trading only to accounts that passed the KYC verification</li> </ul>"},{"location":"verifier/on-chain-verification/overview/#on-chain-verification-flow","title":"On-chain verification flow","text":"On-chain verification workflow  <p>At its core, every on-chain interaction between a Verifier and a user's Wallet follows this workflow:</p> <ul> <li>After having deployed a Verifier Smart Contract, the Verifier designs a Request for the users. This has to be recorded on-chain inside the Verifier Smart Contract. </li> <li>The Request is delivered to the user within a QR code (or via deep-linking; it is up to the implementer).</li> <li>The user scans the QR code using his/her mobile ID wallet and parses the request</li> <li>The user fetches the revocation status of the requested credential from the Issuer of that credential.</li> <li>The user generates a zk proof on mobile according to the request of the website starting from the credentials held in his/her wallet. This also contains the zk proof that the credential is not revoked.</li> <li>The user sends the zk proof to the Verifier Smart Contract.</li> <li>The Verifier Smart Contract verifies the zk Proof.</li> <li>The Verifier Smart Contract checks that the State of the Issuer of the credential and the State of the user are still valid and have not been revoked.</li> <li>If the verification is successful, the Verifier executes the logic defined in the Smart Contract.</li> </ul> <p>Note that an active action from the Verifier is only required at step 1. All the rest of the interaction is between the user and the Smart Contract. All the verification logic is executed programmatically inside the Smart Contract.</p>"},{"location":"verifier/on-chain-verification/overview/#implement-erc20-zk-airdrop-in-20-minutes","title":"Implement ERC20 ZK Airdrop in 20 Minutes","text":"<p>In this tutorial, we will create an ERC20 zk Airdrop Contract. The chosen query criteria is to be born before <code>01/01/2002</code>. Users that are able to prove that were born before that date will be able to get the airdrop. Otherwise, they will not. The proof submitted to the Smart Contract will not reveal any information about the specific date of birth of the user. That is the magic of zero-knowledge! </p> <p>To set up a different query check out the ZK Query Language section</p> <p>This tutorial is based on the verification of a Credential of Type <code>KYCAgeCredential</code> with an attribute <code>birthday</code> with a Schema URL <code>https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld</code>.</p> <p>The prerequisite is that users have the Polygon ID Wallet app installed and self-issued a Credential of type <code>KYC Age Credential Merklized</code> using our Demo Issuer </p> <p>Note: The full executable code related to this tutorial can be cloned from this repository.</p>"},{"location":"verifier/on-chain-verification/overview/#design-the-erc20-zk-airdrop-verifier-contract","title":"Design the ERC20 zk Airdrop Verifier Contract","text":"<p>Let us jump into the code by writing the <code>ERC20Verifier</code> contract. </p> <p>The ERC20Verifier is an ERC20 standard contract on steroids. The extra functionality is given by the zero-knowledge proof verification. All the functions dedicated to the zk verification are contained inside the  ZKPVerifier Contract and inherited within the ERC20Verifier. For example, users will submit their proof to claim the airdrop by calling <code>submitZKPResponse</code>.</p> <p>The ERC20Verifier contract must define at least a single <code>TRANSFER_REQUEST_ID</code>. This is the Identifier of the request that the contract is posing to the user.</p> <p>In this specific case the request is: \"to be born before 01/01/2002\". Note that this hasn't been added yet to the Smart Contract. It will be added in a few minutes!</p> <pre><code>pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./lib/GenesisUtils.sol\";\nimport \"./interfaces/ICircuitValidator.sol\";\nimport \"./verifiers/ZKPVerifier.sol\";\n\ncontract ERC20Verifier is ERC20, ZKPVerifier {\n\nuint64 public constant TRANSFER_REQUEST_ID = 1;\n// define the amount of token to be airdropped per user\nuint256 public TOKEN_AMOUNT_FOR_AIRDROP_PER_ID = 5 * 10**uint(decimals());\n\n\nconstructor(string memory name_, string memory symbol_)\nERC20(name_, symbol_)\n{}    }\n</code></pre> <p>The ZKPVerifier Contract provides 2 hooks: </p> <p><code>_beforeProofSubmit</code> and <code>afterProofSubmit</code>. These hooks are called before and after any proof gets submitted and can be used to create personalized logic inside your Smart Contract.</p> <p>In this specific case, it must be checked that the sender of the proof matches the address contained in the proof challenge. This requirement is necessary to prevent proof front-running. This condition is added inside <code>_beforeProofSubmit</code>.</p> <p>The airdrop logic must be added inside <code>_afterProofSubmit</code>. The contract must execute the airdrop once the proof is correctly verified.</p> <pre><code>contract ERC20Verifier is ERC20, ZKPVerifier {\nuint64 public constant TRANSFER_REQUEST_ID = 1;\n\nmapping(uint256 =&gt; address) public idToAddress;\nmapping(address =&gt; uint256) public addressToId;\nuint256 public TOKEN_AMOUNT_FOR_AIRDROP_PER_ID = 5 * 10**uint(decimals());\n\nconstructor(string memory name_, string memory symbol_)\nERC20(name_, symbol_)\n{}\n\nfunction _beforeProofSubmit(\nuint64, /* requestId */\nuint256[] memory inputs,\nICircuitValidator validator\n    ) internal view override {\n// check that the challenge input of the proof is equal to the msg.sender \naddress addr = GenesisUtils.int256ToAddress(\ninputs[validator.getChallengeInputIndex()]\n);\nrequire(\n_msgSender() == addr,\n\"address in the proof is not a sender address\"\n);\n}\n\nfunction _afterProofSubmit(\nuint64 requestId,\nuint256[] memory inputs,\nICircuitValidator validator\n    ) internal override {\nrequire(\nrequestId == TRANSFER_REQUEST_ID &amp;&amp; addressToId[_msgSender()] == 0,\n\"proof can not be submitted more than once\"\n);\n\nuint256 id = inputs[validator.getChallengeInputIndex()];\n// execute the airdrop\nif (idToAddress[id] == address(0)) {\nsuper._mint(_msgSender(), TOKEN_AMOUNT_FOR_AIRDROP_PER_ID);\naddressToId[_msgSender()] = id;\nidToAddress[id] = _msgSender();\n}\n}\n}\n</code></pre> <p>Finally, we can add a further element of security inside the Smart Contract: prevent any type of token transfer (even after the airdrop) unless users passed the proof verification. This last condition is added by overriding the ERC20 <code>_beforeTokenTransfer</code> function and checking that the receiver address <code>to</code> of the transfer is included inside the  <code>proofs</code> mapping. </p> <pre><code>contract ERC20Verifier is ERC20, ZKPVerifier {\nuint64 public constant TRANSFER_REQUEST_ID = 1;\n\nmapping(uint256 =&gt; address) public idToAddress;\nmapping(address =&gt; uint256) public addressToId;\n\nuint256 public TOKEN_AMOUNT_FOR_AIRDROP_PER_ID = 5 * 10**uint(decimals());\n\nconstructor(string memory name_, string memory symbol_)\nERC20(name_, symbol_)\n{}\n\nfunction _beforeProofSubmit(\nuint64, /* requestId */\nuint256[] memory inputs,\nICircuitValidator validator\n    ) internal view override {\n...\n}\n\nfunction _afterProofSubmit(\nuint64 requestId,\nuint256[] memory inputs,\nICircuitValidator validator\n    ) internal override {\n...\n}\n\nfunction _beforeTokenTransfer(\naddress, /* from */\naddress to,\nuint256 /* amount */\n) internal view override {\nrequire(\nproofs[to][TRANSFER_REQUEST_ID] == true,\n\"only identities who provided proof are allowed to receive tokens\"\n);\n}\n}\n</code></pre> <p>The contract is now fully written!</p>"},{"location":"verifier/on-chain-verification/overview/#deploy-the-contract","title":"Deploy the Contract","text":"<p>Execute this Hardhat script to deploy the contract</p> <pre><code>async function main() {\nconst verifierContract = \"ERC20Verifier\";\nconst verifierName = \"ERC20zkAirdrop\";\nconst verifierSymbol = \"zkERC20\";\n\n\nconst spongePoseidonLib = \"0x12d8C87A61dAa6DD31d8196187cFa37d1C647153\";\nconst poseidon6Lib = \"0xb588b8f07012Dc958aa90EFc7d3CF943057F17d7\";\n\n\nconst ERC20Verifier = await ethers.getContractFactory(verifierContract,{\nlibraries: {\nSpongePoseidon: spongePoseidonLib,\nPoseidonUnit6L: poseidon6Lib\n},\n} );\nconst erc20Verifier = await ERC20Verifier.deploy(\nverifierName,\nverifierSymbol\n);\n\nawait erc20Verifier.deployed();\nconsole.log(verifierName, \" contract address:\", erc20Verifier.address);\n}\n</code></pre> <p>The contract ERC20Verifier must be deployed on the Mumbai test network as there is a set of supporting contracts that are already deployed on Mumbai! </p>"},{"location":"verifier/on-chain-verification/overview/#set-the-zkp-request","title":"Set the ZKP Request","text":"<p>As previously mentioned, the actual zkp request \"to be born before 01/01/2002\" hasn't been added to the Smart Contract yet. To do so it is necessary to call <code>setZKPRequest</code> function inherited inside the ERC20Verifier which takes 6 inputs:</p> <ol> <li><code>requestId</code>: the id associated with the request.</li> <li><code>validator</code>: the address of the Validators Smart Contract already deployed on Mumbai. This is the contracts that executes the verification on the zk proof submitted by the user. It can be of type CredentialAtomicQuerySigValidator or CredentialAtomicQueryMTPValidator.</li> <li><code>schema</code> namely the bigInt representation of the schema of the requested credential. This can be obtained by passing your schema to this Go Sandbox. In order to use the sandbox, the constants <code>jsonLDContext</code>, <code>typ</code>, <code>fieldName</code> and <code>schemaJSONLD</code> need to be modified according to your request.</li> <li><code>claimPathKey</code> represents the path to the queries key inside the merklized credential. In this case it is the path to the <code>birthday</code> key. This can be obtained by passing your schema to this Go Sandbox. In order to use the sandbox, the constants <code>jsonLDContext</code>, <code>typ</code>, <code>fieldName</code> and <code>schemaJSONLD</code> need to be modified according to your request.</li> <li><code>operator</code> is either 1,2,3,4,5,6. To understand more about the operator you can check the zk query language</li> <li><code>value</code> represents the threshold value you are querying. In this case it is the date 01/01/2002. </li> </ol> <p>Check out our Smart Contract section to learn more about the set of verifications executed on the zk proof.</p> <p>Execute this Hardhat script to set the zk request to the Smart Contract.</p> <pre><code>const Operators = {\nNOOP : 0, // No operation, skip query verification in circuit\nEQ : 1, // equal\nLT : 2, // less than\nGT : 3, // greater than\nIN : 4, // in\nNIN : 5, // not in\nNE : 6   // not equal\n}\n\nasync function main() {\n\n// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"74977327600848231385663280181476307657\"\n\n// merklized path to field in the W3C credential according to JSONLD  schema e.g. birthday in the KYCAgeCredential under the url \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\"\nconst schemaClaimPathKey = \"20376033832371109177683048456014525905119173674985843915445634726167450989630\"\n\nconst requestId = 1;\n\nconst query = {\nschema: schemaBigInt,\nclaimPathKey  : schemaClaimPathKey,\noperator: Operators.LT, // operator\nvalue: [20020101, ...new Array(63).fill(0).map(i =&gt; 0)], // for operators 1-3 only first value matters\n};\n\n// add the address of the contract just deployed\nconst ERC20VerifierAddress = \"&lt;ERC20VerifierAddress&gt;\"\n\nlet erc20Verifier = await hre.ethers.getContractAt(\"ERC20Verifier\", ERC20VerifierAddress)\n\n\nconst validatorAddress = \"0xF2D4Eeb4d455fb673104902282Ce68B9ce4Ac450\"; // sig validator\n// const validatorAddress = \"0x3DcAe4c8d94359D31e4C89D7F2b944859408C618\"; // mtp validator\n\ntry {\nawait erc20Verifier.setZKPRequest(\nrequestId,\nvalidatorAddress,\nquery.schema,\nquery.claimPathKey,\nquery.operator,\nquery.value\n);\nconsole.log(\"Request set\");\n} catch (e) {\nconsole.log(\"error: \", e);\n}\n}\n</code></pre> <p>The contract is now correctly deployed on Mumbai Testnet and the query has been set up, congratulations! Now it is time to launch the airdrop! </p>"},{"location":"verifier/on-chain-verification/overview/#add-the-proof-request-inside-a-qr-code","title":"Add the Proof Request Inside a QR Code","text":"<p>The last step is to design the proof request to be embedded inside a QR code that will be shown to the users that want to Credential their airdrops. In this particular case this is how the request should look like (remember to modify it by adding the address of your ERC20Verifier Contract):</p> <pre><code>{\n\"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n\"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"body\": {\n\"reason\": \"airdrop participation\",\n\"transaction_data\": {\n\"contract_address\": \"&lt;ERC20VerifierAddress&gt;\",\n\"method_id\": \"b68967e2\",\n\"chain_id\": 80001,\n\"network\": \"polygon-mumbai\"\n},\n\"scope\": [\n{\n\"id\": 1,\n\"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n\"query\": {\n\"allowedIssuers\": [\n\"*\"\n],\n\"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\",\n\"credentialSubject\": {\n\"birthday\": {\n\"$lt\": 20020101\n}\n},\n\"type\": \"KYCAgeCredential\"\n}\n}\n]\n}\n}\n</code></pre> <p>The scope section inside the JSON file must match the query previously set when calling the \"setZKPRequest\" function</p> <p>Note that the request resembles in most of its parts with the one designed for off-chain verification. The extra part that has been added here is the <code>transcation_data</code> that includes:</p> <ul> <li><code>contract_address</code>, namely the address of the Verifier contract, in this case, ERC20Verifier</li> <li><code>method_id</code>, namely the Function Selector of the <code>submitZKPResponse</code> function</li> <li><code>chain_id</code>, the ID of the chain where the Smart Contract has been deployed</li> <li><code>network</code>, the name of the network where the Smart contract has been deployed</li> </ul> <p>To display the QR code inside your frontend, you can use the <code>express.static</code> built-in middleware function together with this Static Folder or this Code Sandbox.</p> <p>Scanning the QR with their Polygon ID Wallet, users will be able to generate proofs and send transactions to the Smart Contract in order to Credential their airdrops.</p> <p>The same proof generation request can also be delivered to users via Deep Linking. In order to do so is necessary to encode the <code>json</code> file to Base64 Format. The related deep link would be <code>iden3comm://?i_m={{base64EncodedJsonHere}}</code>. For example, in this specific case the deep link would be <code>iden3comm://?i_m=ewogICAgImlkIjogIjdmMzhhMTkzLTA5MTgtNGE0OC05ZmFjLTM2YWRmZGI4YjU0MiIsCiAgICAidHlwIjogImFwcGxpY2F0aW9uL2lkZW4zY29tbS1wbGFpbi1qc29uIiwKICAgICJ0eXBlIjogImh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9wcm9vZnMvMS4wL2NvbnRyYWN0LWludm9rZS1yZXF1ZXN0IiwKICAgICJ0aGlkIjogIjdmMzhhMTkzLTA5MTgtNGE0OC05ZmFjLTM2YWRmZGI4YjU0MiIsCiAgICAiYm9keSI6IHsKICAgICAgICAicmVhc29uIjogImFpcmRyb3AgcGFydGljaXBhdGlvbiIsCiAgICAgICAgInRyYW5zYWN0aW9uX2RhdGEiOiB7CiAgICAgICAgICAgICJjb250cmFjdF9hZGRyZXNzIjogIjxFUkMyMFZlcmlmaWVyQWRkcmVzcz4iLAogICAgICAgICAgICAibWV0aG9kX2lkIjogImI2ODk2N2UyIiwKICAgICAgICAgICAgImNoYWluX2lkIjogODAwMDEsCiAgICAgICAgICAgICJuZXR3b3JrIjogInBvbHlnb24tbXVtYmFpIgogICAgICAgIH0sCiAgICAgICAgInNjb3BlIjogWwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAiaWQiOiAxLAogICAgICAgICAgICAgICAgImNpcmN1aXRJZCI6ICJjcmVkZW50aWFsQXRvbWljUXVlcnlTaWdWMk9uQ2hhaW4iLAogICAgICAgICAgICAgICAgInF1ZXJ5IjogewogICAgICAgICAgICAgICAgICAgICJhbGxvd2VkSXNzdWVycyI6IFsKICAgICAgICAgICAgICAgICAgICAgICAgIioiCiAgICAgICAgICAgICAgICAgICAgXSwKICAgICAgICAgICAgICAgICAgICAiY29udGV4dCI6ICJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vaWRlbjMvY2xhaW0tc2NoZW1hLXZvY2FiL21haW4vc2NoZW1hcy9qc29uLWxkL2t5Yy12My5qc29uLWxkIiwKICAgICAgICAgICAgICAgICAgICAiY3JlZGVudGlhbFN1YmplY3QiOiB7CiAgICAgICAgICAgICAgICAgICAgICAgICJiaXJ0aGRheSI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICIkbHQiOiAyMDAyMDEwMQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAidHlwZSI6ICJLWUNBZ2VDcmVkZW50aWFsIgogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgXQogICAgfQp9</code></p>"},{"location":"verifier/on-chain-verification/overview/#user-demo-claim-the-airdrop","title":"User Demo: Claim the Airdrop!","text":"<p>This video shows how a user can use their PolygonID wallet app to claim a ERC-20 token airdrop. To join the airdrop users are required to have a Credential of type <code>KYCAgeCredential</code> attesting that they have been born before 01/01/2002.</p> <p>Or you can direcly test it scanning the QR Code below using your Polygon ID App: </p> <p></p>"},{"location":"verifier/on-chain-verification/overview/#how-the-proof-submission-is-executed","title":"How the proof submission is executed?","text":"<p>The wallet needs to call the <code>submitZKPResponse()</code> function before it can submit the proof for the requirements set in the Airdrop Participation process. This function forms part of the ZKPVerifier Interface <code>IZKPVerifier</code> and is actually implemented inside the <code>ZKPVerifier Contract</code></p> <pre><code>import \"./ICircuitValidator.sol\";\n\ninterface IZKPVerifier {\nfunction submitZKPResponse(\nuint64 requestId,\nuint256[] memory inputs,\nuint256[2] memory a,\nuint256[2][2] memory b,\nuint256[2] memory c\n    ) external returns (bool);\n}\n</code></pre>"},{"location":"verifier/on-chain-verification/overview/#extend-it-to-your-own-logic","title":"Extend it to Your Own Logic","text":"<p>Now that you have been able to create your first on-chain zk-based application you can extend it to accommodate any type of imaginable logic. The target Smart Contract doesn't have to be an ERC20 but it can be an ERC721, a DeFi pool, a voting Smart Contract or whatever contract you can think of. Equally the query can be extended to any type of existing Credential and based on the different operators available inside the ZK Query Language.</p> <p>Another possibility to customize your Smart Contract involves setting different zk requests. First of all, multiple <code>REQUEST_ID</code> must be defined inside the main Smart Contract. Therefore, the contract deployer can set a different query for each request ID and create different outcomes inside <code>_afterProofSubmit</code> according to the type of proof received. For example, an airdrop contract can verify the role of a user inside a DAO and distribute a different amount of tokens based on the role.</p>"},{"location":"verifier/on-chain-verification/overview/#further-tutorial-for-on-chain-verification","title":"Further Tutorial for On-chain Verification","text":"<ul> <li>Polygon ID On-chain Verifications - Codingwithmanny, contains a more detailed explanation of the ERC20 Airdrop using Polygon ID. Furthermore it contains a section for debugging common errors and for minting an NFT starting from on-chain Polygon ID Credential Verification.</li> </ul>"},{"location":"verifier/verification-library/config/","title":"Configuration","text":"<p>The set of APIs included in the verification library can be split into two steps:</p> <ul> <li>Request APIs allow to design the request to be presented to the user in order to authenticate.</li> <li>Verification APIs allow verifying the proof sent by the user. The proof is generated as response to the request. </li> </ul> <p>Check the workflow to disambiguate between these two processes</p> <p>Both the APIs are available either in Golang or Javascript:</p> GoLangJavascript <pre><code>go get github.com/iden3/go-iden3-auth\n</code></pre> <pre><code>import (\n\"github.com/iden3/go-circuits\"\nauth \"github.com/iden3/go-iden3-auth\"\n\"github.com/iden3/go-iden3-auth/loaders\"\n\"github.com/iden3/go-iden3-auth/pubsignals\"\n\"github.com/iden3/go-iden3-auth/state\"\n\"github.com/iden3/iden3comm/protocol\"\n)\n</code></pre> <pre><code>npm i @iden3/js-iden3-auth --save\n</code></pre> <pre><code>const {auth, resolver, protocol, loaders, circuits} = require('@iden3/js-iden3-auth')\n</code></pre>"},{"location":"verifier/verification-library/request-api-guide/","title":"Request API","text":"<p>The first step of interacting with a wallet involves presenting a request. In this tutorial, we will explain the difference between two types of requests: Basic Auth Request and Query-based Request.</p> <p>A Basic Auth Request allows to design a minimal DID request to the user. As a response to that, the user will share a proof that he/she is the owner of that DID.</p> <p>A Query-based Request allows to design a more complex query request to the user. As a response to that, the user will share a proof that he/she owns a credential that satisfies the properties defined inside the query.</p>"},{"location":"verifier/verification-library/request-api-guide/#basic-auth-request","title":"Basic Auth Request","text":"<p>The Basic Auth Request allows verifiers to interact with a wallet and authenticate the user by its DID. Basic Auth Request can be implemented by any platform that is interested in providing a seamless web2-like login experience to its users without setting any specific requirements.</p>"},{"location":"verifier/verification-library/request-api-guide/#createauthorizationrequest","title":"CreateAuthorizationRequest","text":"GoLangJavascript <pre><code>var request protocol.AuthorizationRequestMessage\nrequest = auth.CreateAuthorizationRequest(reason, audience, url)\n</code></pre> <pre><code>const request : protocol.AuthorizationRequestMessage = auth.createAuthorizationRequest(reason, audience, url)\n</code></pre> <p>An example of the usage of this api can be found here (GO) and here (JS)</p> <p>Generate an Auth Request to the user that includes a reason for authenticating. The audience represents the DID of the requester, while the url is the callback url where the user must send the response for verification</p>"},{"location":"verifier/verification-library/request-api-guide/#createauthorizationrequestwithmessage","title":"CreateAuthorizationRequestWithMessage","text":"GoLangJavascript <pre><code>var request protocol.AuthorizationRequestMessage\nrequest = auth.CreateAuthorizationRequestWithMessage(reason, messageToSign, audience, url)\n</code></pre> <pre><code>const request : protocol.AuthorizationRequestMessage = auth.createAuthorizationRequestWithMessage(reason, messageToSign, audience, url)\n</code></pre> <p>The same functionality of CreateAuthorizationRequest but it also includes a messageToSign. This message will be shown to the users inside their wallets and will be signed as part of the response.</p>"},{"location":"verifier/verification-library/request-api-guide/#query-based-request","title":"Query-based Request","text":"<p>The Query-based Auth Request allows verifiers to interact with a wallet by setting up specific requirements for authentication. These requirements are the conditions that the user has to satisfy based on the credentials held in his/her wallet.</p> <p>The Query has to be attached to the Basic Auth Request output of the previous API. An example of its usage can be found here</p> GoLangJavascript <pre><code>var mtpProofRequest protocol.ZeroKnowledgeProofRequest\nmtpProofRequest.ID = 1\nmtpProofRequest.CircuitID = string(circuits.AtomicQuerySigV2CircuitID)\nmtpProofRequest.Query = map[string]interface{}{\n\"allowedIssuers\": []string{\"*\"},\n\"credentialSubject\": map[string]interface{}{\n\"birthday\": map[string]interface{}{\n\"$lt\": 20000101,\n},\n},\n\"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\",\n\"type\":    \"KYCAgeCredential\",\n}\nrequest.Body.Scope = append(request.Body.Scope, mtpProofRequest)\n</code></pre> <pre><code>const proofRequest: protocol.ZKPRequest = {\nid: 1,\ncircuitId: 'credentialAtomicQuerySigV2',\nquery: {\nallowedIssuers: ['*'],\ntype: 'KYCAgeCredential',\ncontext: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld',\ncredentialSubject: {\nbirthday: {\n$lt: 20000101,\n},\n},\n},\n};\nrequest.body.scope = [...scope, proofRequest];\n</code></pre> <p>Generate a request to prove that the user owns a credential that satisfies certain requirements. </p> <p><code>ID</code> represents the request id: ideally, in production, it should be a unique value for each request. <code>CircuitID</code> represents the identifier of the circuit that the user must use to generate the requested proof: here you can find a reference to the available circuits. </p> <p>In this case, the user has to provide a proof that he/she owns a credential issued by the <code>allowedIssuer</code> of schema <code>type</code> KYCAgeCredential described in the url provided in <code>context</code>. This is the JSON-LD context of the credential. By setting the <code>allowedIssuer</code> to <code>*</code>, the user can provide a proof of that credential issued by any issuer. Alternatively, if the verifier adds the DID of a specific issuer inside the <code>allowedIssuer</code> array, the user must provide a proof of a credential issued by that specific issuer. This credential contains details in its <code>credentialSubject</code> of the birthday of the receiver. In this scenario, the user has to prove that the value contained in the attribute <code>birthday</code> is less than <code>lt</code> 20000101, namely that the user was born before 01/01/2000.</p> <p>An additional optional field that can be included in the query is <code>skipClaimRevocationCheck</code>. By setting it to <code>true</code>, the user doesn't need to provide the proof of the revocation of the credential, which would otherwise be provided by default.  This is useful for credentials that are still useful even if they have been revoked. For example, a credential that states that a user is an employee of Google, is still useful even if it has been revoked after the user left the company and the credential was revoked.</p> <pre><code>mtpProofRequest.Query = map[string]interface{}{\n...\n\"skipClaimRevocationCheck\": true,\n...\n}\n</code></pre> <p>An example of the usage of this api can be found here (GO) and here (JS)</p> <p>Check out our Query Language guide to design any type of query request you can think of!</p> <p>Check out the Iden3Comm section inside the Wallet SDK to learn more about how these requests are interpreted by the wallet in order to generate a zk proof</p>"},{"location":"verifier/verification-library/verification-api-guide/","title":"Verification","text":"<p>After having presented a Request to the user's wallet, the wallet will process the request and generate a proof that is sent back to the Verifier.  The proof must be verified in order to authenticate the user.  Let us see how to execute this verification.</p> <p>The proof verification always follows the same flow independently of the Request type presented in the previous step by the Verifier, whether it is a basic auth or a query-based request.</p> <p>Unpack the proof </p> GoLangJavascript <pre><code>import (\n\"io\"\n)\n\ntokenBytes, err := io.ReadAll(req.Body)\n</code></pre> <pre><code>const getRawBody = require('raw-body')\n\nconst raw = await getRawBody(req);\nconst tokenStr = raw.toString().trim();\n</code></pre> <p><code>req</code> is the post request sent by the wallet in response to the Auth Request posed by the Verifier. This unpacks the proof sent by the wallet.</p> <p>Initiate the verifier</p> GoLangJavascript <pre><code>var verificationKeyloader = &amp;loaders.FSKeyLoader{Dir: keyDIR}\nresolver := state.ETHResolver{\nRPCUrl:          ethURL,\nContractAddress: common.HexToAddress(contractAddress),\n}\n\nresolvers := map[string]pubsignals.StateResolver{\nresolverPrefix: resolver,\n}\n\nverifier := auth.NewVerifier(verificationKeyloader, loaders.DefaultSchemaLoader{IpfsURL: \"ipfs.io\"}, resolvers)\n</code></pre> <pre><code>const verificationKeyloader = new loaders.FSKeyLoader(keyDIR);\nconst sLoader = new loaders.UniversalSchemaLoader('ipfs.io');\n\nconst ethStateResolver = new resolver.EthStateResolver(\nethURL,\ncontractAddress,\n);\n\nconst resolvers: resolver.Resolvers = {\n['polygon:mumbai']: ethStateResolver,\n};\n\nconst verifier = new auth.Verifier(\nverificationKeyloader,\nsLoader, resolvers,\n);\n</code></pre> <p>This creates a resolver which is used to fetch the identity state from the State Smart Contract and a verification key loader which is used to fetch the verification keys necessary to verify a zero knowledge proof.  Eventually, it returns an instance of a Verifier. To set up a verifier different parameters need to be passed:</p> <ul> <li><code>keyDIR</code> is the path where the public verification keys for iden3 circuits are located (such as <code>\"./keys\"</code>). The verification key folder can be found here.</li> <li><code>ethURL</code> is the URL of your RPC node provider such as <code>\"https://polygon-testnet-rpc.allthatnode.com:8545\"</code> for Polygon Mumbai.</li> <li><code>contractAddress</code> is the address of the identity state Smart Contract. On Polygon Mumbai, it is 0x134B1BE34911E39A8397ec6289782989729807a4.</li> <li><code>resolverPrefix</code> is the prefix of the resolver. For Polygon Mumbai it is <code>\"polygon:mumbai\"</code></li> </ul> <p>Execute the verification</p> GoLangJavascript <pre><code>authResponse, err := verifier.FullVerify(\nr.Context(),\nstring(tokenBytes),\nauthRequest.(protocol.AuthorizationRequestMessage),\npubsignals.WithAcceptedStateTransitionDelay(time.Minute*5))\n</code></pre> <pre><code>let authResponse: protocol.AuthorizationResponseMessage;\n\nconst opts: VerifyOpts = {\nAcceptedStateTransitionDelay: 5 * 60 * 1000, // 5 minute\n};\n\nauthResponse = await verifier.fullVerify(tokenStr, authRequest, opts);\n</code></pre> <p>Execute the verification. It verifies that the proof shared by the user satisfies the criteria set by the Verifier inside the initial request. <code>tokenBytes</code> contains the proof generated by the user's wallet. <code>authRequest</code> is the request previously presented to that specific user. <code>AcceptedStateTransitionDelay(time.Minute*5))</code> is the delay accepted by the Verifier. By setting it to 5 minutes, as in this case, the Verifier accepts a proof that verifies the validity of a credential against a state, as stated in the Smart Contract, which is up to 5 minutes old.</p> <p>An example of the usage of this api can be found here (GO) and here (JS)</p>"},{"location":"verifier/verification-library/verification-api-guide/#verification-under-the-hood","title":"Verification - Under the Hood","text":"<p>The auth library provides a simple handler to extract all the necessary metadata from the proof and execute all the verifications needed. The verification procedure that is happening behind the scenes involves the following steps: </p>"},{"location":"verifier/verification-library/verification-api-guide/#zero-knowledge-proof-verification","title":"Zero-Knowledge Proof Verification","text":"<p>Starting from the circuit-specific public verification key, the proof, and the public inputs provided by the user, it is possible to verify the proof. In this case, the proof verification involves: </p> <ul> <li>Verification of the proof contained based on the <code>AuthV2 Circuit</code></li> <li>Verification of the proof contained based on the <code>AtomicQuerySigV2 Circuit</code> or <code>AtomicQueryMTPV2</code> based on the query.</li> </ul>"},{"location":"verifier/verification-library/verification-api-guide/#verification-of-on-chain-identity-states","title":"Verification of On-chain Identity States","text":"<p>Starting from the DID of the user, the State is fetched from the blockchain and compared to the state provided as input to the proof; this is done to check whether the user is the actual \"owner\" of the state used to generate the proof or not. It is important to note here that there is no gas cost associated with the verification as the VerifyState method just reads the identity state of the user on-chain without making any operations/smart contract calls. The same verification is performed for the Issuer's Identity State.</p> <p>In this part, it is also verified that the requested credential has not been revoked by the Issuer.</p>"},{"location":"verifier/verification-library/verification-api-guide/#verification-of-circuit-public-inputs","title":"Verification of Circuit Public Inputs","text":"<p>This involves a verification based on the public inputs of the circuits used to generate the proof. These must match the rules requested by the Verifier inside the Auth Request. For example, the query and the credential schema used by the user to generate the proof must match the Auth Request:</p> <ul> <li>The message signed by the user is the same must match the one passed to the user inside the auth request.</li> <li>The rules such as the <code>query</code> or the credential <code>schema</code> used to generate the proof must match the ones included inside the auth request. </li> </ul> <p>This \"off-circuit\" verification is important because a user can potentially modify the query and present a valid proof. A user born after 2000-12-31 shouldn't pass the check. But if they generate a proof using a query input <code>\"$lt\": 20010101</code>, the Verifier would see it as a valid proof. By doing verification of the public inputs of the circuit, the Verifier is able to detect malicious actors.</p> <p>At the end of the workflow:</p> <ul> <li>The web client is able to authenticate the user using its DID <code>ID</code> after having established that the user controls that identity and satisfies the query presented in the auth request.</li> <li>The user is able to log into the platform without disclosing any personal information to the client except for its DID.</li> </ul>"},{"location":"verifier/verification-library/verifier-library-intro/","title":"Introduction","text":"Off-chain verification workflow  <p>At its core, every off-chain interaction between a Verifier and a user's Wallet follows this workflow:</p> <ul> <li>A web application designs a request for the users. This is delivered to the user within a QR code (or via deep-linking; it is up to the implementer). This can either be a auth request or a query-based request.</li> <li>The user scans the QR code using his/her mobile ID wallet and parses the request</li> <li>The user fetches the revocation status of the requested credential from the Issuer of that credential.</li> <li>The user generates a zk proof on mobile according to the request of the website starting from the credentials held in his/her wallet. This also contains the zk proof that the credential is not revoked.</li> <li>The user sends the zk proof to the Verifier.</li> <li>The Verifier verifies the zk Proof using the verification API.</li> <li>The Verifier checks that the State of the Issuer of the credential and the State of the user are still valid and have not been revoked (this is still performed using the same verification API).</li> <li>If the verification is successful, the Verifier grants access to the user (or activates any customized logic)</li> </ul> <p>Assume that the request is: \"Are you over 18 years old?\". The Verifier never gets access to any of the user's credentials. Instead, the Verifier receives a cryptographic proof which, on verification, provides an answer \"yes\" or \"no\" to the previous question. </p> <p>This section provides all the elements needed to integrate off-chain verification with Polygon ID.</p>"},{"location":"verifier/verification-library/verifier-library-intro/#libraries","title":"Libraries","text":"<p>The authentication flow can be implemented either in GoLang or Javascript</p> <ul> <li> <p>Go Iden3 Verification Library</p> </li> <li> <p>JS Iden3 Verification Library</p> </li> </ul>"},{"location":"verifier/verification-library/verifier-set-up/","title":"Run a Verifier","text":"<p>Any application that wants to authenticate user based on their Polygon ID Identity off-chain must set up a Verifier. A Verifier is made of a Server and a Client. </p> <p>The Server generates the ZK Request according to the requirements of the platform. There are two types of authentication:</p> <ul> <li>Basic Auth: For example, a platform that issues Credentials must authenticate users by their identifiers before sharing Credentials with them. </li> <li>Query-based Auth: For example, a platform that gives access only to those users that are over 18 years of age.</li> </ul> <p>The second role of the Server is to execute Verification of the proof sent by the Identity Wallet.</p> <p>The Verifier Client is the point of interaction with the user. In its simplest form, a client needs to embed a QR code that displays the zk request generated by the Server. The verification request can also be delivered to users via Deep Linking. After scanning the zk request, the user will generate a proof based on that request locally on their wallet. This proof is therefore sent back to the Verifier Server that verifies whether the proof is valid.</p> <p>This tutorial is based on the verification of a Credential of Type <code>KYCAgeCredential</code> with an attribute <code>birthday</code> with a Schema URL <code>https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld</code>.</p> <p>The prerequisite is that users have the Polygon ID Wallet app installed and self-issued a Credential of type <code>KYC Age Credential Merklized</code> using our Demo Issuer. Further credentials can be issued using the Issuer Node.</p> <p>In this example, the verifier will set up the query: \"Prove that you were born before the <code>2000/01/01</code>. To set up a different query check out the ZK Query Language section</p> <p>Note: The executable code for this section can be found here.</p>"},{"location":"verifier/verification-library/verifier-set-up/#verifier-server-setup","title":"Verifier Server Setup","text":"<ol> <li> <p>Add the authorization package to your project </p> GoLangJavascript <pre><code>go get github.com/iden3/go-iden3-auth\n</code></pre> <pre><code>npm i @iden3/js-iden3-auth\n</code></pre> </li> <li> <p>Set up a server </p> <p>Initiate a server that contains two endpoints: </p> <ul> <li>GET /api/sign-in: Returns auth request.</li> <li>POST /api/callback: Receives the callback request from the identity wallet containing the proof and verifies it.</li> </ul> GoLangJavascript <pre><code>package main\n\nimport (\n\"encoding/json\"\n\"fmt\"\n\"io\"\n\"log\"\n\"net/http\"\n\"strconv\"\n\"time\"\n\n\"github.com/ethereum/go-ethereum/common\"\n\"github.com/iden3/go-circuits\"\nauth \"github.com/iden3/go-iden3-auth\"\n\"github.com/iden3/go-iden3-auth/loaders\"\n\"github.com/iden3/go-iden3-auth/pubsignals\"\n\"github.com/iden3/go-iden3-auth/state\"\n\"github.com/iden3/iden3comm/protocol\"\n)\n\nfunc main() {\nhttp.HandleFunc(\"/api/sign-in\", GetAuthRequest)\nhttp.HandleFunc(\"/api/callback\", Callback)\nhttp.ListenAndServe(\":8080\", nil)\n}\n\n// Create a map to store the auth requests and their session IDs\nvar requestMap = make(map[string]interface{})\n</code></pre> <pre><code>const express = require('express');\nconst {auth, resolver, loaders} = require('@iden3/js-iden3-auth')\nconst getRawBody = require('raw-body')\n\nconst app = express();\nconst port = 8080;\n\napp.get(\"/api/sign-in\", (req, res) =&gt; {\nconsole.log('get Auth Request');\nGetAuthRequest(req,res);\n});\n\napp.post(\"/api/callback\", (req, res) =&gt; {\nconsole.log('callback');\nCallback(req,res);\n});\n\napp.listen(port, () =&gt; {\nconsole.log('server running on port 8080');\n});\n\n// Create a map to store the auth requests and their session IDs\nconst requestMap = new Map();\n</code></pre> </li> <li> <p>Sign-in endpoint </p> <p>This endpoint generates the auth request for the user. Using this endpoint, the developers set up the requirements that users must meet in order to authenticate.</p> <p>If created using Polygon ID Platform, the schema URL can be fetched from there and pasted inside your Query</p> GoLangJavascript <pre><code>func GetAuthRequest(w http.ResponseWriter, r *http.Request) {\n\n// Audience is verifier id\nrURL := \"NGROK URL\"\nsessionID := 1\nCallbackURL := \"/api/callback\"\nAudience := \"did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs\"\n\nuri := fmt.Sprintf(\"%s%s?sessionId=%s\", rURL, CallbackURL, strconv.Itoa(sessionID))\n\n// Generate request for basic authentication\nvar request protocol.AuthorizationRequestMessage = auth.CreateAuthorizationRequest(\"test flow\", Audience, uri)\nrequest.ID = \"7f38a193-0918-4a48-9fac-36adfdb8b542\"\nrequest.ThreadID = \"7f38a193-0918-4a48-9fac-36adfdb8b542\"\n// Add request for a specific proof\nvar mtpProofRequest protocol.ZeroKnowledgeProofRequest\nmtpProofRequest.ID = 1\nmtpProofRequest.CircuitID = string(circuits.AtomicQuerySigV2CircuitID)\nmtpProofRequest.Query = map[string]interface{}{\n\"allowedIssuers\": []string{\"*\"},\n\"credentialSubject\": map[string]interface{}{\n\"birthday\": map[string]interface{}{\n\"$lt\": 20000101,\n},\n},\n\"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld\",\n\"type\":    \"KYCAgeCredential\",\n}\nrequest.Body.Scope = append(request.Body.Scope, mtpProofRequest)\n// Store auth request in map associated with session ID\nrequestMap[strconv.Itoa(sessionID)] = request\n\n// print request\nfmt.Println(request)\n\nmsgBytes, _ := json.Marshal(request)\n\nw.Header().Set(\"Content-Type\", \"application/json\")\nw.WriteHeader(http.StatusOK)\nw.Write(msgBytes)\nreturn\n}\n</code></pre> <pre><code>async function GetAuthRequest(req,res) {\n\n// Audience is verifier id\nconst hostUrl = \"&lt;NGROK_URL&gt;\";\nconst sessionId = 1;\nconst callbackURL = \"/api/callback\"\nconst audience = \"did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs\"\n\nconst uri = `${hostUrl}${callbackURL}?sessionId=${sessionId}`;\n\n// Generate request for basic authentication\nconst request = auth.createAuthorizationRequest(\n'test flow',\naudience,\nuri,\n);\nrequest.id = '7f38a193-0918-4a48-9fac-36adfdb8b542';\nrequest.thid = '7f38a193-0918-4a48-9fac-36adfdb8b542';\n// Add request for a specific proof\nconst proofRequest = {\nid: 1,\ncircuitId: 'credentialAtomicQuerySigV2',\nquery: {\nallowedIssuers: ['*'],\ntype: 'KYCAgeCredential',\ncontext: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld',\ncredentialSubject: {\nbirthday: {\n$lt: 20000101,\n},\n},\n},\n};\nconst scope = request.body.scope ?? [];\nrequest.body.scope = [...scope, proofRequest];\n// Store auth request in map associated with session ID\nrequestMap.set(`${sessionId}`, request);\n\nreturn res.status(200).set('Content-Type', 'application/json').send(request);\n}\n</code></pre> <p>Note: The highlighted lines are to be added only if the authentication needs to design a query for a specific proof as in the case of Query-based Auth. When not included, it will perform a Basic Auth. </p> </li> <li> <p>Callback Endpoint</p> <p>The request generated in the previous endpoint already contains the CallBackURL so that the response generated by the wallet will be automatically forwarded to the server callback function. The callback post endpoint receives the proof generated by the identity wallet. The role of the callback endpoint is to execute the Verification on the proof.</p> <p>To ADD: The identity state <code>contractAddress</code> on Polygon Mumbai is 0x134B1BE34911E39A8397ec6289782989729807a4. The public verification keys for iden3 circuits generated after the trusted setup can be found here and must be added to your project inside a folder called <code>keys</code>. Also, don't forget to add the Mumbai RPC endpoint (such as Alchemy or Infura) inside the <code>ethURL</code> variable!</p> GoLangJavascript <pre><code>// Callback works with sign-in callbacks\nfunc Callback(w http.ResponseWriter, r *http.Request) {\n\n// Get session ID from request\nsessionID := r.URL.Query().Get(\"sessionId\")\n\n// get JWZ token params from the post request\ntokenBytes, _ := io.ReadAll(r.Body)\n\n// Add Polygon Mumbai RPC node endpoint - needed to read on-chain state\nethURL := \"https://polygon-testnet-rpc.allthatnode.com:8545\"\n\n// Add identity state contract address\ncontractAddress := \"0x134B1BE34911E39A8397ec6289782989729807a4\"\n\nresolverPrefix := \"polygon:mumbai\"\n\n// Locate the directory that contains circuit's verification keys\nkeyDIR := \"../keys\"\n\n// fetch authRequest from sessionID\nauthRequest := requestMap[sessionID]\n\n// print authRequest\nfmt.Println(authRequest)\n\n// load the verifcation key\nvar verificationKeyloader = &amp;loaders.FSKeyLoader{Dir: keyDIR}\nresolver := state.ETHResolver{\nRPCUrl:          ethURL,\nContractAddress: common.HexToAddress(contractAddress),\n}\n\nresolvers := map[string]pubsignals.StateResolver{\nresolverPrefix: resolver,\n}\n\n// EXECUTE VERIFICATION\nverifier := auth.NewVerifier(verificationKeyloader, loaders.DefaultSchemaLoader{IpfsURL: \"ipfs.io\"}, resolvers)\nauthResponse, err := verifier.FullVerify(\nr.Context(),\nstring(tokenBytes),\nauthRequest.(protocol.AuthorizationRequestMessage),\npubsignals.WithAcceptedStateTransitionDelay(time.Minute*5))\nif err != nil {\nlog.Println(err.Error())\nhttp.Error(w, err.Error(), http.StatusInternalServerError)\nreturn\n}\n\nuserID := authResponse.From\n\nmessageBytes := []byte(\"User with ID \" + userID + \" Successfully authenticated\")\n\nw.WriteHeader(http.StatusOK)\nw.Header().Set(\"Content-Type\", \"application/json\")\nw.Write(messageBytes)\n\nreturn\n}\n</code></pre> <pre><code>async function Callback(req,res) {\n\n// Get session ID from request\nconst sessionId = req.query.sessionId;\n\n// get JWZ token params from the post request\nconst raw = await getRawBody(req);\nconst tokenStr = raw.toString().trim();\n\nconst ethURL = '&lt;MUMBAI_RPC_URL&gt;';\nconst contractAddress = \"0x134B1BE34911E39A8397ec6289782989729807a4\"\nconst keyDIR = \"../keys\"\n\nconst ethStateResolver = new resolver.EthStateResolver(\nethURL,\ncontractAddress,\n);\n\nconst resolvers = {\n['polygon:mumbai']: ethStateResolver,\n};\n\n\n// fetch authRequest from sessionID\nconst authRequest = requestMap.get(`${sessionId}`);\n\n// Locate the directory that contains circuit's verification keys\nconst verificationKeyloader = new loaders.FSKeyLoader(keyDIR);\nconst sLoader = new loaders.UniversalSchemaLoader('ipfs.io');\n\n// EXECUTE VERIFICATION\nconst verifier = new auth.Verifier(\nverificationKeyloader,\nsLoader,\nresolvers,\n);\n\n\ntry {\nconst opts = {\nAcceptedStateTransitionDelay: 5 * 60 * 1000, // 5 minute\n};        authResponse = await verifier.fullVerify(tokenStr, authRequest, opts);\n} catch (error) {\nreturn res.status(500).send(error);\n}\nreturn res.status(200).set('Content-Type', 'application/json').send(\"user with ID: \" + authResponse.from + \" Succesfully authenticated\");\n}\n</code></pre> </li> </ol> <p>If you need to deploy an App or to build a Docker container you'll need to bundle the libwasmer.so library together with the app. </p>"},{"location":"verifier/verification-library/verifier-set-up/#verifier-client-setup","title":"Verifier Client Setup","text":"<p>The Verifier Client must fetch the Auth Request generated by the Server (\"/api/sign-in\" endpoint) and deliver it to the user via a QR Code. </p> <p>To display the QR code inside your frontend, you can this Code Sandbox.</p> <p>The same request can also be delivered to users via Deep Linking. In order to do so is necessary to encode the <code>request</code> file to Base64 Format. The related deep link would be <code>iden3comm://?i_m={{base64EncodedRequestHere}}</code>.</p> <p>Implement Further Logic</p> <p>This tutorial showcased a minimalistic application that leverages Polygon ID libraries for authentication purposes. Developers can leverage the broad set of existing Credentials held by users to set up any customized Query using our zk Query Language to unleash the full potential of the framework. </p> <p>For example, the concept can be extended to exchanges that require KYC Credentials, DAOs that require proof-of-personhood Credentials, or social media applications that intend to re-use users' aggregated reputation.</p> <p>To do so, add the Static Folder to your Verifier repository. This folder contains an HTML static webpage that renders a static webpage with the QR code containing the Auth Request.</p> <p>To display the QR code inside your frontend, you can use the <code>express.static</code> built-in middleware function together with this Static Folder or this Code Sandbox.</p> <ol> <li> <p>Add routing to your Express Server</p> <p>To serve static files, we use the express.static built-in middleware function.</p> <pre><code>const express = require('express');\nconst {auth, resolver, loaders} = require('@iden3/js-iden3-auth')\nconst getRawBody = require('raw-body')\n\nconst app = express();\nconst port = 8080;\n\napp.use(express.static('static'));\napp.get(\"/api/sign-in\", (req, res) =&gt; {\nconsole.log('get Auth Request');\nGetAuthRequest(req,res);\n});\n\napp.post(\"/api/callback\", (req, res) =&gt; {\nconsole.log('callback');\nCallback(req,res);\n});\n\napp.listen(port, () =&gt; {\nconsole.log('server running on port 8080');\n});\n\n// Create a map to store the auth requests and their session IDs\nconst requestMap = new Map();\n</code></pre> </li> <li> <p>Visit http://localhost:8080/</p> <p>When visiting the URL, the users will need to scan the QR code with their id wallets.</p> <p>  Sign Up with Polygon ID - Client Side  <li> <p>Implement Further Logic</p> <p>This tutorial showcased a minimalistic application that leverages Polygon ID libraries for authentication purposes. Developers can leverage the broad set of existing Credentials held by users to set up any customized Query using our zk Query Language to unleash the full potential of the framework. </p> <p>For example, the concept can be extended to exchanges that require KYC Credentials, DAOs that require proof-of-personhood Credentials, or social media applications that intend to re-use users' aggregated reputation.</p> </li>"},{"location":"verifier/verification-library/zk-query-language/","title":"Query Language","text":"<p>The <code>Atomic Query Signature V2 Circuit</code> and <code>Atomic Query MTP V2 Circuit</code> circuits have been designed as generic circuits to do the zk verification based on users' claims. </p> <p>The Query Language sits on top of these circuits to provide a simple way for developers to design customised authentication requirements based on someone's credentials. As long as the user holds a credential of a specific type, the Verifier can design a query related to the Credentials based on 6 operators, for example:  </p> <ul> <li>Must be a verified human to vote for a DAO specific proposal - <code>equals</code> (operator 1).</li> <li>Must have been born before 2000-01-01 to access an adult content website - <code>less-than</code> (operator 2).</li> <li>Must have a monthly salary greater than $1000 to get a loan - <code>greater-than</code> (operator 3).</li> <li>Must be an admin or an hacker of a Dao to enter a platform - <code>\u00ecn</code> (operator 4).</li> <li>Must not be a resident of a country in the list of blacklisted countries to operate on an exchange - <code>not-in</code> (operator 5).</li> <li>Must not be a resident of a specific country - <code>not-equal</code> (operator 6).</li> </ul> <p>The query is designed by the Verifier and presented to the user via a QR Code (or deep-linking). Starting from the proof generated by the user as a response to the query, the Verifier is easily able to check if the query is satisfied or not. The Verifier doesn't get access to any user's data.</p> <p>The Query Language follows the same rules whether the verification is implemented on-chain or off-chain, while the syntax to define these is a bit different. For each of the query presented above, both the on-chain and off-chain way of designing will now be defined. </p> <p>The entire scripts to set a query are available here: off-chain verification, on-chain verification</p> <p>Further examples on how to setup customized queries will be released soon!</p>"},{"location":"verifier/verification-library/zk-query-language/#equals-operator-1","title":"Equals - Operator 1","text":"<p>Credential Schema</p> <p>The <code>ProofOfHumanity</code> Schema encodes whether a user has been verified as a human or not. Here's the JSON-LD Context of the Schema Type.</p> <p>You can create customised schemas, check out this tutorial! </p> <p>Query</p> <p>When presented with this query, the user must prove that he/she is a Person.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\nid: 1,\ncircuitId: 'credentialAtomicQuerySigV2',\nquery: {\nallowedIssuers: ['*'],\ntype: 'ProofOfHumanity',\ncontext: 'https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/proof-of-humanity/proof-of-humanity.jsonld',\ncredentialSubject: {\nisHuman: {\n$eq: 1,\n},\n},\n},\n};\n</code></pre> <p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"324849518749029195374186444632030216125\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"14815366841010849835350402710291849818496586666144492189460088557509920034090\"\n\nconst requestId = 1;\n\nconst query = {\nschema: schemaBigInt,\nclaimPathKey  : schemaClaimPathKey,\noperator: 1,\nvalue: [1, ...new Array(63).fill(0).map(i =&gt; 0)], // for operators 1,2,3,6 only first value matters\n};\n</code></pre> <pre><code>// Corresponding QR Code\n{\n\"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n\"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"body\": {\n\"reason\": \"airdrop participation\",\n\"transaction_data\": {\n\"contract address\" : \"&lt;add your contract address here&gt;\", // replace with your contract address\n\"method_id\": \"b68967e2\",\n\"chain_id\": 80001,\n\"network\": \"polygon-mumbai\"\n},\n\"scope\": [\n{\n\"id\": 1,\n\"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n\"query\": {\n\"allowedIssuers\": [\n\"*\"\n],\n\"context\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/proof-of-humanity/proof-of-humanity.jsonld\",\n\"credentialSubject\": {\n\"isHuman\": {\n\"$eq\": 1\n}\n},\n\"type\": \"ProofOfHumanity\"\n}\n}\n]\n}\n}\n</code></pre></p>"},{"location":"verifier/verification-library/zk-query-language/#less-than-operator-2","title":"Less-than - Operator 2","text":"<p>Credential Schema</p> <p>The <code>KYCAgeCredential</code> Schema encodes the date of birth of the credential subject. Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that he/she has been born before 2001/01/01.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\nid: 1,\ncircuitId: 'credentialAtomicQuerySigV2',\nquery: {\nallowedIssuers: ['*'],\ntype: 'KYCAgeCredential',\ncontext: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld',\ncredentialSubject: {\nbirthday: {\n$lt: 20010101,\n},\n},\n},\n};\n</code></pre> <p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"267831521922558027206082390043321796944\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"20376033832371109177683048456014525905119173674985843915445634726167450989630\"\n\nconst requestId = 1;\n\nconst query = {\nschema: schemaBigInt,\nclaimPathKey  : schemaClaimPathKey,\noperator: 1,\nvalue: [1, ...new Array(63).fill(0).map(i =&gt; 0)],  // for operators 1,2,3,6 only first value matters\n};\n</code></pre> <pre><code>// Corresponding QR Code\n{\n\"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n\"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"body\": {\n\"reason\": \"airdrop participation\",\n\"transaction_data\": {\n\"contract address\" : \"&lt;add your contract address here&gt;\",\n\"method_id\": \"b68967e2\",\n\"chain_id\": 80001,\n\"network\": \"polygon-mumbai\"\n},\n\"scope\": [\n{\n\"id\": 1,\n\"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n\"query\": {\n\"allowedIssuers\": [\n\"*\"\n],\n\"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld\",\n\"credentialSubject\": {\n\"birthday\": {\n\"$lt\": 20010101\n}\n},\n\"type\": \"KYCAgeCredential\"\n}\n}\n]\n}\n}\n</code></pre></p>"},{"location":"verifier/verification-library/zk-query-language/#greater-than-operator-3","title":"Greater-than - Operator 3","text":"<p>Credential Schema</p> <p>The <code>EmployeeData</code> Schema encodes the monthly salary of the credential subject. Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that his/her monthly salary is greater than $1000.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\nid: 1,\ncircuitId: 'credentialAtomicQuerySigV2',\nquery: {\nallowedIssuers: ['*'],\ntype: 'EmployeeData',\ncontext: 'https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/employee-data/employee-data.jsonld',\ncredentialSubject: {\nmonthlySalary: {\n$gt: 1000,\n},\n},\n},\n};\n</code></pre> <p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"215529050624769177581695011121804343416\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"18323209396655941018370955962714740724727867245625378697671016248362870463698\"\n\nconst requestId = 1;\n\nconst query = {\nschema: schemaBigInt,\nclaimPathKey  : schemaClaimPathKey,\noperator: 3, // operator\nvalue: [1000, ...new Array(63).fill(0).map(i =&gt; 0)],\n};\n</code></pre> <pre><code>{\n\"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n\"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"body\": {\n\"reason\": \"airdrop participation\",\n\"transaction_data\": {\n\"contract address\" : \"&lt;add your contract address here&gt;\",\n\"method_id\": \"b68967e2\",\n\"chain_id\": 80001,\n\"network\": \"polygon-mumbai\"\n},\n\"scope\": [\n{\n\"id\": 1,\n\"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n\"query\": {\n\"allowedIssuers\": [\n\"*\"\n],\n\"context\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/employee-data/employee-data.jsonld\",\n\"credentialSubject\": {\n\"monthlySalary\": {\n\"$gt\": 1000\n}\n},\n\"type\": \"EmployeeData\"\n}\n}\n]\n}\n}\n</code></pre></p>"},{"location":"verifier/verification-library/zk-query-language/#in-operator-4","title":"In - Operator 4","text":"<p>Credential Schema</p> <p>The <code>ProofOfDaoRole</code> Schema encodes the role of someone inside a DAO. Each role is identified by a code as described in the Schema Vocab.</p> <p>Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that he/she is either an Admin or an Hacker of a DAO (which corresponds to value 4 and 5).</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\nid: 1,\ncircuitId: 'credentialAtomicQuerySigV2',\nquery: {\nallowedIssuers: ['*'],\ntype: 'ProofOfDaoRole',\ncontext: 'https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/proof-of-dao-role/proof-of-dao-role.jsonld',\ncredentialSubject: {\nrole: {\n$in: [4, 5],\n},\n},\n},\n};\n</code></pre> <p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"80689572245316684375295691372009959153\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"19483179179477598314891505360164348442915562939736565831310034495973163044179\"\n\nconst requestId = 1;\n\nconst query = {\nschema: schemaBigInt,\nclaimPathKey  : schemaClaimPathKey,\noperator: 4, // operator\nvalue: [4, 5, ...new Array(62).fill(0).map(i =&gt; 0)],\n};\n</code></pre> <pre><code>// Corresponding QR Code\n{\n\"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n\"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"body\": {\n\"reason\": \"airdrop participation\",\n\"transaction_data\": {\n\"contract address\" : \"&lt;add your contract address here&gt;\",\n\"method_id\": \"b68967e2\",\n\"chain_id\": 80001,\n\"network\": \"polygon-mumbai\"\n},\n\"scope\": [\n{\n\"id\": 1,\n\"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n\"query\": {\n\"allowedIssuers\": [\n\"*\"\n],\n\"context\": \"https://raw.githubusercontent.com/0xPolygonID/tutorial-examples/main/credential-schema/schemas-examples/proof-of-dao-role/proof-of-dao-role.jsonld\",\n\"credentialSubject\": {\n\"role\": {\n\"$in\": [4, 5]\n}\n},\n\"type\": \"ProofOfDaoRole\"\n}\n}\n]\n}\n}\n</code></pre></p>"},{"location":"verifier/verification-library/zk-query-language/#not-in-operator-5","title":"Not-in - Operator 5","text":"<p>Credential Schema</p> <p>The <code>KYCCountryOfResidenceCredential</code> Schema encodes the countryCode of residence of the credential subject according to the ISO Standard. Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that he/she is not resident of the countries <code>840, 120, 340, 509</code> identified following the ISO Standard.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\nid: 1,\ncircuitId: 'credentialAtomicQuerySigV2',\nquery: {\nallowedIssuers: ['*'],\ntype: 'KYCCountryOfResidenceCredential',\ncontext: 'https://github.com/iden3/claim-schema-vocab/blob/main/schemas/json-ld/kyc-v4.jsonld',\ncredentialSubject: {\ncountryCode: {\n$nin: [840, 120, 340, 509],\n},\n},\n},\n};\n</code></pre> <p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"201134713754279235117373236841506344285\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"17002437119434618783545694633038537380726339994244684348913844923422470806844\"\n\nconst requestId = 1;\n\nconst query = {\nschema: schemaBigInt,\nclaimPathKey  : schemaClaimPathKey,\noperator: 5, // operator\nvalue: [840, 120, 340, 509, ...new Array(60).fill(0).map(i =&gt; 0)],\n};\n</code></pre> <pre><code>// Corresponding QR Code\n{\n\"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n\"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"body\": {\n\"reason\": \"airdrop participation\",\n\"transaction_data\": {\n\"contract address\" : \"&lt;add your contract address here&gt;\",\n\"method_id\": \"b68967e2\",\n\"chain_id\": 80001,\n\"network\": \"polygon-mumbai\"\n},\n\"scope\": [\n{\n\"id\": 1,\n\"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n\"query\": {\n\"allowedIssuers\": [\n\"*\"\n],\n\"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld\",\n\"credentialSubject\": {\n\"countryCode\": {\n\"$nin\": [840, 120, 340, 509]\n}\n},\n\"type\": \"KYCCountryOfResidenceCredential\"\n}\n}\n]\n}\n}\n</code></pre></p>"},{"location":"verifier/verification-library/zk-query-language/#not-equal-operator-6","title":"Not-equal - Operator 6","text":"<p>Credential Schema</p> <p>The <code>KYCCountryOfResidenceCredential</code> Schema encodes the countryCode of residence of the credential subject according to the ISO Standard. Here's the JSON-LD Context of the Schema Type.</p> <p>Query</p> <p>When presented with this query, the user must prove that he/she is not resident of the country <code>840</code> identified following the ISO Standard.</p> off-chainon-chain <pre><code>  const proofRequest: protocol.ZKPRequest = {\nid: 1,\ncircuitId: 'credentialAtomicQuerySigV2',\nquery: {\nallowedIssuers: ['*'],\ntype: 'KYCCountryOfResidenceCredential',\ncontext: 'https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld',\ncredentialSubject: {\ncountryCode: {\n$ne: 840\n},\n},\n},\n};\n</code></pre> <p><pre><code>// you can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using YOUR schema\nconst schemaBigInt = \"201134713754279235117373236841506344285\"\n\n// merklized path to field in the W3C credential according to JSONLD schema \nconst schemaClaimPathKey = \"17002437119434618783545694633038537380726339994244684348913844923422470806844\"\n\nconst requestId = 1;\n\nconst query = {\nschema: schemaBigInt,\nclaimPathKey  : schemaClaimPathKey,\noperator: 6,\nvalue: [840, ...new Array(63).fill(0).map(i =&gt; 0)], // for operators 1,2,3,6 only first value matters\n};\n</code></pre> <pre><code>// Corresponding QR Code\n{\n\"id\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/proofs/1.0/contract-invoke-request\",\n\"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"body\": {\n\"reason\": \"airdrop participation\",\n\"transaction_data\": {\n\"contract address\" : \"&lt;add your contract address here&gt;\",\n\"method_id\": \"b68967e2\",\n\"chain_id\": 80001,\n\"network\": \"polygon-mumbai\"\n},\n\"scope\": [\n{\n\"id\": 1,\n\"circuitId\": \"credentialAtomicQuerySigV2OnChain\",\n\"query\": {\n\"allowedIssuers\": [\n\"*\"\n],\n\"context\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v4.jsonld\",\n\"credentialSubject\": {\n\"countryCode\": {\n\"$ne\": 840\n}\n},\n\"type\": \"KYCCountryOfResidenceCredential\"\n}\n}\n]\n}\n}\n</code></pre></p>"},{"location":"wallet/wallet-overview/","title":"Wallet Overview","text":"<p>A digital wallet is a software that can hold and manage users' <code>Credentials</code>. Based on the principles of Self-Sovereign Identity (SSI) and cryptography, a wallet helps its Holder share data with others without expositing any other sensitive private information stored on it. Only the wallet holder has the right to decide which information to share with other entities and what needs to remain private. </p> <p>The Polygon ID Wallet is a <code>Privacy by Default</code> wallet that helps protect a user's identity (and other metadata) by using zero-knowledge proofs. The wallet interacts with an Issuer to fetch credentials and with Verifier for sharing zkProofs based on these credentials.</p> <p>The Polygon ID Wallet app is a reference implementation built using our Wallet SDK. Any other web3 wallets would be able to leverage the Wallet SDK to add the same functionalities. </p> <p></p> <p>Note: Currently, we support only mobile-based apps as wallets. The web-based applications and cold-storage wallets are not yet supported. </p> <p>Note: Polygon ID Wallet is built using Flutter SDK. No other SDK is supported yet. </p>"},{"location":"wallet/wallet-overview/#quick-start","title":"Quick Start","text":"<p>To get started with the Polygon ID Wallet, download the Polygon ID Wallet App and create an Identity:</p> <ul> <li>For Android: Polygon ID on Google Play</li> <li>For iOS: Polygon ID on the App Store</li> </ul>"},{"location":"wallet/wallet-overview/#features-of-the-polygon-id-wallet","title":"Features of the Polygon ID Wallet","text":"<p>The Polygon ID Wallet supports the following features:</p> <ul> <li>Privacy by design and Self-sovereignty: The user is in full control of his/her identity data and exchanges credentials with other identities without the need for an intermediary or centralized authority. </li> <li>Open and Permissionless. </li> <li>Fetching, storing, and managing credentials.</li> <li>Generating cost-optimized zero-knowledge proofs for credentials verification.</li> <li>Communication with Issuer and Verifier.</li> <li>Identity recovery using seed phrase.</li> </ul> <p>It is worth noticing that, in order to comply with the principles of the Self-Sovereign Identity (SSI), all the credentials are stored only locally on your wallet and are not stored on-chain; this ensures strong privacy for the sensitive data related to your credential(s). </p>"},{"location":"wallet/wallet-overview/#how-is-polygon-id-wallet-different-from-other-wallets","title":"How is Polygon ID Wallet Different from Other Wallets?","text":"<p>You, at some point in time, must have used cryptographic wallets such as Metamask, Trust Wallet, Coinbase Wallet, Ledger, and so many more. How is Polygon ID Wallet different from all these hot and cold storage wallets? Let us see:</p> <ul> <li> <p>The wallets like Metamask and Trust Wallet are used for sending and receiving crypto transactions on-chain. Polygon ID Wallet, on the other hand, is used for creating and storing unique identities for the wallet so that these identities can be used to authenticate with the Issuer and the Verifier. This Identity wallet helps an Integrator fetch and save credentials from Issuers and also present proof of these credentials to the Verifiers. </p> </li> <li> <p>While the commonly-used crypto wallets let you interact with Ethereum and other blockchain networks using RPCs (Remote Procedure Calls), this is not the case with Polygon ID Wallet - it functions solely to store credentials linked to an identity and lets these credentials get verified by creating zero-knowledge proofs. </p> </li> <li> <p>General wallets store cryptographic keys while the Polygon ID Wallet stores users' identities. While both types of wallets are based on private-public key cryptography, the two are different in the sense that in a wallet like MetaMask, the elliptic curve used is <code>secp256k1</code>, which is used to convert a private key to a public key and eventually to an Ethereum Address, which identifies your wallet. On the other hand, Polygon ID Wallet is based on the <code>Baby Jubjub Key</code> which generates Polygon Id Identifier, which is the identifier for your wallet instead of the Ethereum Wallet Address. </p> </li> </ul>"},{"location":"wallet/wallet-overview/#polygon-id-wallet-sdk","title":"Polygon ID Wallet SDK","text":"<p>The Polygon ID Wallet is built (this is, currently, under development) using Flutter SDK. We refer to this SDK as <code>Polygon ID Wallet SDK</code>. An Integrator can use this Polygon ID Wallet SDK to either create their own apps (that provide similar functionality as that of the Polygon ID Wallet App) or integrate the functionalities seamlessly with their existing apps. </p>"},{"location":"wallet/wallet-overview/#why-polygon-id-wallet-sdk","title":"Why Polygon ID Wallet SDK?","text":"<p>Integrating your app with Polygon ID Wallet SDK can provide you with the major features of an SSI system. As it is built on zero-knowledge protocol, it can let you create an identity application that is not only robust but also maintains high standards of privacy for your users, thus letting them protect their sensitive data from the third-party while revealing only the required information. The Polygon ID Wallet SDK lets you:</p> <ul> <li>Create an Identity for a wallet</li> <li>Remove and restore identities from a wallet.</li> <li>Authenticate your wallet with an Issuer/Verifier.</li> <li>Receive credentials from an Issuer and store them on the wallet.</li> <li>Update credentials and remove them from the wallet when required.</li> <li>Generate zero-knowledge proof that can be sent to a Verifier for verification. </li> </ul>"},{"location":"wallet/wallet-sdk/flutter-sdk/build-app-with-flutter-sdk/","title":"Build App with SDK","text":"<p># Build an App using Flutter: First Few Steps</p> <p>Once your Flutter and Dart plugins are installed, you can start creating your first Flutter app.</p> <ol> <li>On the Terminal or Powershell, change your directory to where you want to install your app:    <pre><code>cd new-app-directory\n</code></pre></li> <li> <p>Create your first app; let's call it \"firstapp\".    <pre><code>flutter create firstapp\nflutter run\n</code></pre>    With these commands, the Flutter SDK creates a new project from scratch.</p> </li> <li> <p>Flutter creates your app.</p> </li> <li> <p>Change your directory to your app:</p> </li> </ol> <pre><code>cd firstapp\n</code></pre> <p>Note: In your directory, inside your app, there is a <code>lib</code> folder, which contains a <code>main.dart</code> file. When you click <code>main.dart</code>, it opens in your editor. This file contains the Dart code and for your own app, you will need to replace the content of this .dart file with your own code.</p>"},{"location":"wallet/wallet-sdk/flutter-sdk/build-app-with-flutter-sdk/#pubspecyaml-file","title":"Pubspec.yaml File","text":"<p>In your app folder, click the <code>pubspec.yaml</code> to open it in your editor. The <code>pubspec.yaml</code> file contains the following information about your app:</p> <ul> <li>Name of your app</li> <li>Description</li> <li>Version and build number of your app</li> <li>Environment</li> <li>Dependencies</li> </ul>"},{"location":"wallet/wallet-sdk/flutter-sdk/build-app-with-flutter-sdk/#add-dependencies-of-your-app-to-pubspecyaml","title":"Add Dependencies of your app to Pubspec.yaml","text":"<p>Dependencies are any additional packages that your app requires to run smoothly. These dependencies can be automatically updated to the latest version by running the following command:</p> <p><pre><code>flutter pub upgrade --major-versions\n</code></pre> To update the dependencies manually, change the dependency version number to the latest one.</p>"},{"location":"wallet/wallet-sdk/flutter-sdk/flutter-sdk-overview/","title":"All About Flutter SDK","text":"<p>Flutter SDK is a set of tools that are built in Dart programming language and let the developers create and test apps. It is an open-source, platform-agnostic framework that helps in building mobile apps. Flutter SDK provides a developer with CLI(Command Line Interface) tools and APIs that help built cross-platform apps. </p> <p>Flutter plug-in package helps in implementing code for a specific platform: Android/iOS/web. To know more about different types of packages and the plugins provided by Flutter, click here.</p>"},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/","title":"Install Flutter SDK","text":""},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/#steps-to-install-flutter-sdk","title":"Steps to Install Flutter SDK","text":"<p>Flutter SDK installation is available for different operating systems including Windows, macOS, Linux, and ChromeOS.</p> <ol> <li>Click here to select your operating system.</li> <li>Check for the system requirements specific to each operating system and make sure that you have all the necessary tools already installed on your system. For instance, for macOS, <code>git</code> must be pre-installed while for Windows, you need to have <code>git for Windows</code> and <code>Windows Powershell 5.0 or above</code> installed.</li> <li> <p>Download the installation bundle (install the latest version for stable release ) relevant to your Operating System. In the case of macOS, different bundles are available for Intel and Apple Silicon processors.</p> </li> <li> <p>Extract the downloaded installation file to the desired directory on your machine. This creates a flutter folder in the directory. </p> </li> <li> <p>On your Terminal, change the directory to the flutter folder extracted in the previous step.</p> <p><pre><code>cd flutter\n</code></pre> 6. To run the flutter commands, the shell you are working in must be set to the directory where your flutter binary file (.exe) is located. For this, you must first set the path:</p> <p><pre><code>export PATH=\"$PATH:/[path where Flutter is installed]/flutter/bin\"\n</code></pre> For example, if our extracted installation is on your Desktop, we can run the following command: <pre><code>export PATH=\"$PATH:/Users/username/Desktop/flutter/bin\"\n</code></pre> where <code>export</code> sets the <code>PATH</code> on the left to the value of the <code>PATH</code> specified on the right. </p> <p>To verify if the Path has been correctly set, we run an <code>echo $PATH</code> command:</p> <p><pre><code>echo $PATH\n</code></pre> /opt/homebrew/bin:/opt/homebrew/sbin:/opt/local/bin:/opt/local/sbin:/Library/Frameworks/Python.framework/Versions/3.10/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin:/Library/Apple/usr/bin:/usr/local/bin:/Users/username/Desktop/flutter/bin</p> <p>where the path in the bold is the intended path where we had set our path to.</p> </li> </ol>"},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/#using-dart-with-flutter","title":"Using Dart with Flutter","text":"<p>Flutter apps are created using a programming language called <code>Dart</code>. An object-oriented language with similarity to C language, Dart is used for creating mobile and web applications. With Dart, Flutter apps can be developed quickly and deployed to different platforms.</p> <p>Note: The Dart SDK comes bundled with Flutter, so if you installed Flutter, it is not required to install Dart separately.</p> <p>Note: For more information on Dart, click here.</p>"},{"location":"wallet/wallet-sdk/flutter-sdk/install-flutter-sdk/#install-flutter-plugin-for-text-editors","title":"Install Flutter Plugin for Text Editors","text":"<p>Generally, developers can create a Flutter-based app using a combination of the CLI (Command Line Interface) and a text editor. The easier way is to install a plugin within the editor. The plugins for editors like Visual Studio Code, Android Studio, Emacs, and IntelliJ are available for installation. To install the plugin for both Flutter and Dart on VS Code:</p> <ol> <li>Open VS Code.</li> <li>Click View menu, and then click Command Palette.</li> <li>On the palette, enter Extensions. The system displays a list of options. Select Extensions: Install Extensions.</li> <li>In the Search Extension in Markdown box, enter flutter. The system displays the Flutter plugin. Click install.This installs Flutter along with the Dart plugin.</li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/","title":"Polygon ID SDK Plugin: Example App","text":"<p>To use Polygon ID Mobile SDK, we have created a Polygon ID SDK Plugin. This plugin helps you communicate with our Polygon ID Platform. </p> <p>The following steps illustrate how to do initial setup to get things started and then use this plugin to create an identity, authenticate this identity, fetch a credential from an Issuer using identity, and generate a proof to verify (by Verifier) this credential. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Install Flutter: Install Flutter SDK. To know the steps in detail, read tutorial here.</p> </li> <li> <p>Clone Repository: Clone the polygonid-sdk-repository.</p> </li> <li> <p>Set Directory: On your Terminal, change the directory to <code>example</code>, which is a folder in the <code>polygonid-sdk-repository</code>.</p> <pre><code>cd example\n</code></pre> </li> <li> <p>Set Dependencies: To use the Polygon ID Flutter SDK plugin, add the following dependencies to your <code>pubspec.yaml</code> file:</p> <p>environment:</p> <pre><code>    sdk: \"&gt;=2.17.0 &lt;3.0.0\"\n</code></pre> <p>dependencies:</p> <pre><code>    flutter:\n          sdk: flutter\n\n    polygonid_flutter-sdk: ^x.y.z\n\n    where \"^x.y.z\" stands for the version constraints (range of versions that are backward compatible with the x.y.z version. For more details on version constraints, click [here](https://dart.dev/tools/pub/dependencies#version-constraints)\n</code></pre> <p>Read more here.</p> </li> <li> <p>Get Dart packages: While in the <code>example</code> directory, run the following command:</p> <p><pre><code>flutter pub get\n</code></pre>   The system runs the command and shows:</p> <p>Running \"flutter pub get\" in example...</p> <p>where <code>pub</code> command (in Dart) invokes a set of tools for managing Dart packages and <code>pub get</code> downloads these packages for your Dart project. The <code>flutter pub get</code> indicates that the command is run via flutter SDK.</p> </li> <li> <p>Build your first project and run it. For more details, click here.</p> </li> </ol> <p>Note:  While running a flutter command, if you encounter a command not found: flutter error, make sure that the path set above is correct. If you still encounter the error, install Vim emulation for Visual Studio Code as an extension and follow these steps:</p> <ol> <li> <p>Run the following command:    <pre><code>vim $HOME/.zshrc\n</code></pre>       where we assume that you are working in the Z shell. If you are using the Bash shell, you can run this command:    <pre><code>vim $HOME/.bashrc\n</code></pre> Note: To know your shell, type:       <pre><code>echo $SHELL\n</code></pre>       which, in our case shows: <code>/bin/zsh</code></p> </li> <li> <p>This opens the <code>.zshrc</code> configuration window (for the Z Shell). Press \"I\" to initiate the insert mode.</p> </li> <li> <p>Run the following command to set your path variable:    <pre><code>export PATH=\"$PATH:/Flutter-Directory-Path/flutter/bin\"\n</code></pre>    where \"Flutter-Directory-Path\" is the directory where your Flutter is installed.</p> </li> <li> <p>Press <code>Escape</code> on your keyboard and then enter the following command:    <pre><code>:wq!\n</code></pre>    Press <code>Enter</code>. This saves the file in vim and exits the editor (<code>wq</code> stands for write and quit).</p> </li> <li> <p>Run your flutter commands.</p> </li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#general-flow","title":"General Flow","text":""},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#overview","title":"Overview","text":"<p>In the upcoming sections, we shall see the general flow of how to use the Polygon ID SDK plugin. The steps are summarised as:</p> <p>A. Identity</p> <ol> <li>Initialise Polygon ID SDK.</li> <li>Create an Identity for the wallet.</li> <li>Get (Retrieve) Identifier from the Identity created in the previous step.</li> <li>Remove Identity (only if required).</li> <li>Get iden3Message from Issuer.</li> <li>Authenticate Identity using Identifier, iden3Message, and Private Key.</li> </ol> <p>B. Credential</p> <ol> <li>Create CredentialRequestEntity from the Iden3Message received from an Issuer.</li> <li>Fetch and Save credentials (received from Issuer)on SDK using CredentialRequestEntity, Identifier, and Private Key.</li> <li>Get credentials that are saved on wallet SDK. Can also retrieve them with credential ids.</li> <li>Remove credential(s) (only if required).</li> <li>Update credential (only if required).</li> </ol> <p>C. Proof</p> <ol> <li>Generate zero-knowledge proof using iden3Message, Identifier, and Private Key. </li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#steps-in-detail","title":"Steps in Detail","text":"<p>A. Identity</p> <p>This part of the flow consists of initialising Polygon ID SDK, creating an identifier for an identity and retrieving it, and using the identifier to authenticate the Identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/example-app/#1-initiate-polygon-id-sdk","title":"1. Initiate Polygon ID SDK","text":"<p>To start using Polygon ID SDK, an integrator needs to initialize it first. This is done inside the dependency injection initializer using <code>await PolygonIdSDK.init()</code>.  <pre><code>import 'package:flutter/material.dart';\nimport 'package:polygonid_flutter_sdk/sdk/polygon_id_sdk.dart';\n\nFuture&lt;void&gt; main() async {\n  await PolygonIdSdk.init();\n  runApp(const App());\n}\n</code></pre></p> <p>If the SDK has not been initialized, the system throws an exception: <code>PolygonIsSdkNotInitializedException</code> indicating that the Polygon ID SDK has not been initialized and must be initialized first with <code>await PolygonIdSDK.init()</code>.</p> <p>After the SDK initialization, the Integrator  will need to use the instance of PolygonIdSDK:</p> <p><pre><code>getIt.registerLazySingleton&lt;PolygonIdSdk&gt;(() =&gt; PolygonIdSdk.I)\n ```\n\n#### ***2. Create Identity***\n\nAfter SDK initialization, the SDK checks the existence of an Identifier that was previously created with the `createIdentity()` function. \nIf no previously created Identifier is found, the SDK first needs to create an identity first using `identity.createIdentity()` function. \n</code></pre> Future createIdentity() async {   // we get the sdk instance previously initialized   final sdk = PolygonIdSdk.I;   PrivateIdentityEntity identity = await sdk.identity.createIdentity(secret: secretKey); } <pre><code>You can retrieve your `private key` from the `PrivateIdentityEntity` specified in the code above. Keep this private key safe; it will be used in a few other SDK methods as you will see in the following steps.\n\n**Note**: It is not mandatory to pass the `secret` as the input parameter in the function. If you do not pass it, a random `secret` is generated by the system. \n\n\n\n#### ***3. Get Identifier***\n\nThis retrieves the `identifier` by passing the `private key` as the input parameter to the `getIdentifier()` function; please note that the `private key` is generated from `PrivateIdentityEntity` that we generated via `createIdentity()` function in the previous section. \n</code></pre> Future getIdentifier() async {   String privateKey = privateIdentityEntity.privateKey;   String identifier = await sdk.identity.getIdentifier(privateKey: privateKey); } <pre><code>#### ***4. Remove Identity***\n\nTo remove an existing Identity (use this only when required), you need to call the `identity.removeIdentity()` with `identifier` and the `privateKey` as the input parameters. \n</code></pre> Future removeIdentity({   required String privateKey,   required String identifier, }) async {   await sdk.identity.removeIdentity(     privateKey: privateKey,     identifier: identifier,   ); <pre><code>#### ***5. Authenticate Identity***\n\nThe authentication includes two steps:\n- Generate an iden3messgae from the QR code\n- Authenticate Identity using iden3message\n\n**a. Generate Iden3Message**\n\nAn Integrator uses `iden3Message` to communicate with an Issuer/Verifier. This 'iden3message' is created from the QR code scanned by the Integrator on his/her wallet. The `getIden3Message()` uses a message (created after scanning the QR code) as the input parameter and generates `iden3Message`.\n</code></pre> Iden3MessageEntity getIden3MessageFromString(String message){   return sdk.iden3comm.getIden3Message(message: message); } <pre><code>**b. Authenticate Identity using Iden3Message**\n\nWe use `authenticate()` to authenticate an identity by using `privateKey`, `identifier`, and `iden3Message` as the input parameters. \n</code></pre> Future authenticate({   required Iden3MessageEntity iden3message,   required String identifier,   required String privateKey, }) async {   await sdk.iden3comm.authenticate(     iden3message: iden3message,     identifier: identifier,     privateKey: privateKey,   ); } <pre><code>**B. Credential**\n\nThis part of the flow consists of retrieving credentials from an Issuer and saving them in the wallet. One or more credentials can be retrieved and one or more credentials can be removed from the wallet. \n\n#### ***1. Fetch and Save Credentials***\n\nThis functionality consists of retreiving credentials from an Issuer (by fetching them) and then saving them on the wallet.\n\nThis involves:\n- Generate `CredentialRequestEntity` using `identifier`, `callbackUrl`, and `thid` and `from` fields of `iden3Message`. `thid`is the id of the message and `from` stands for the identifier from which Verifier requests proof.\n- Fetch and Save credentials using `CredentialRequestEntity`, `identifier`, and `privateKey`.\n</code></pre> Future fetchAndSaveClaims({   required Iden3MessageEntity iden3message,   required String identifier,   required String privateKey, }) async {   Map? messageBody = iden3message.body; <p>// url for the callback   final String callbackUrl = messageBody['url'];   // credentials   List credentials = messageBody['credentials'];   List credentialRequestEntityList =       credentials.map((credential) {     String credentialId = credential['id'];     return CredentialRequestEntity(       identifier,       callbackUrl,       credentialId,       iden3message.thid,       iden3message.from,     );   }).toList(); <p>await sdk.iden3comm.fetchAndSaveClaims(     credentialRequests: credentialRequestEntityList,     identifier: identifier,     privateKey: privateKey,   ); } <pre><code>#### ***2. Get Credentials***\n\nOnce credentials have been saved on the wallet SDK, these can be retrieved by the Integrator using `credential.getClaims()` with `identifier`, and `privateKey` used as the mandatory input parameters and `filters` as an optional one. `Filters` let an Integrate get credentials based on some pre-determined criteria. \n</code></pre> Future getAllClaims({   List? filters,   required String identifier,   required String privateKey, }) async {   List claimList = await sdk.claim.getAllClaims(     filters: filters,     identifier: identifier,     privateKey: privateKey,   ); } <pre><code>#### ***3. Get Credentials by Ids***\n\nThis functionality lets an Integrator get credentials from an Issuer based on their ids. The `claimId`, `identifier`, and `privateKey`are passed as input parameters to the `credential. getClaimsByIds()` function and a list of credentials in form of `ClaimEntity` are retrieved. The id of each credential is stored on the SDK from where they can be retrieved.\n</code></pre> Future getClaimsByIds({   required List claimIds,   required String identifier,   required String privateKey, }) async {   List claimList = await sdk.credential.getClaimsByIds(     claimIds: claimIds,     identifier: identifier,     privateKey: privateKey,   ); } <pre><code>#### ***4. Remove a Credential***\n\nA credential can be removed from the wallet using `credential.removeClaim()` by passing `claimId` (the id of the credential to be removed), the `identifier` and the `privateKey` as the input parameters. \n</code></pre> Future removeClaim({   required String claimId,   required String identifier,   required String privateKey, }) async {   await sdk.credential.removeClaim(     claimId: claimId,     identifier: identifier,     privateKey: privateKey,   ); } <pre><code>#### ***5. Remove  Multiple Credentials***\n\nThis is similar to removing a single credential described above. In this case, you need to pass a list of `claimids` to be removed, the `identifier`, and the `privateKey` as the input parameters to `credential.removeClaims()`.\n</code></pre> Future removeClaims({   required List claimIds,   required String identifier,   required String privateKey, }) async {   await sdk.credential.removeClaims(     claimIds: claimIds,     identifier: identifier,     privateKey: privateKey,   ); } <pre><code>#### ***6. Update Credential***\n\nTo update a credential, `credential.updateClaim()` function is used with the following fields passed as input parameters:\n- `claimId`\n- `identifier`\n- `privateKey`\n-  other information such as identity `state`, `issuer`, credential's `expiration` date, `type` of credential, etc. \n\n**Note**: Updating a credential means only the `info` field related to it can be changed. \n</code></pre> Future updateClaim({   required String claimId,   required String identifier,   required String privateKey,   String? issuer,   ClaimState? state,   String? expiration,   String? type,   Map? data, }) async {   PolygonIdSdk sdk = PolygonIdSdk.I;   await sdk.credential.updateClaim(     id: claimId,     identifier: identifier,     privateKey: privateKey,     issuer: issuer,     state: state,     expiration: expiration,     type: type,     data: data,   ); } ```"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-overview/","title":"Polygon ID SDK Overview","text":"<p>Like any other SDK, the Polygon ID SDK is a set of tools that consists of core components including libraries, code samples, APIs, and documentation that have been used to create the Polygon ID Wallet App. An Integrator can use this PolygonID SDK to either create their own apps (that provide similar functionality as that of the Polygon ID Wallet App) or integrate the functionalities seamlessly with their existing apps. </p> <p>Disclaimer: Polygon ID Wallet SDK is not production-ready yet and will be subject to major changes in the upcoming months.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-overview/#polygon-id-sdk-and-polygon-id-wallet-app","title":"Polygon ID SDK and Polygon ID Wallet App","text":"<p>In the wallet tutorials, you would be reading terms like Polygon ID SDK and Polygon ID Wallet APP repeatedly. Do not let the terminology confuse you here!! The Polygon ID SDK and the Polygon ID Wallet App are different concepts: the prior is the technology and the later one is one of its possible implementation. </p> <p>While, as you read above, Polygon ID SDK is the software development kit that acts as a core functionality, Wallet App is an application that has been built over this SDK. This Identity Wallet helps Integrators create identities for their wallets and authenticate these identities while interacting with Issuers and Verifiers. </p> <p>Here, we can conclude that an Integrator can use Polygon ID SDK to build an Identity Wallet of his/her own or can also customize any pre-existing identity wallets using the features provided by the SDK.  </p> <p>In the sections to come, you will read more about the Polygon ID SDK plugin and also an example app that will guide you to the initial setup required for using this plugin. In the later part of this example app, you will get to know the overall flow of the functionality that this plugin provides.  </p> <p>Note: Please note that the iOS Simulator for testing the Polygon ID SDK application is still under maintenance and would be available to use soon. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-plugin/","title":"Polygon ID SDK Plugin","text":"<p>The Polygon ID Mobile SDK uses a flutter plugin that lets you interact with the Polygon ID platform. It is a tool that lets you use everything that Polygon ID provides (identity wallet, credential wallet, proof generation, etc.)</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/polygonid-sdk-plugin/#install-polygon-id-mobile-sdk-plugin","title":"Install Polygon ID Mobile SDK Plugin","text":"<p>To use the Polygon ID Flutter SDK plugin, you need to add this plugin as a dependency in your <code>pubspec.yaml</code> file:</p> <ol> <li>Open the <code>pubspec.yaml</code> file in your editor.</li> <li> <p>Scroll down to the dependency section and add the following dependency:</p> <p><pre><code>dependencies:\npolygonid_flutter_sdk: ^x.y.z\n</code></pre> where x stands for the major version, y stands for the minor version, and z stands for the patch version of the Polygon ID Flutter SDK.</p> </li> </ol> <p>If you are working on a branch of the Polygon ID Flutter SDK repository, you can add dependency in the following way: <pre><code>dependencies:\n polygonid_flutter_sdk:\n   git:\n     url: ssh://git@github.com/iden3/polygonid-flutter-sdk.git\n     ref: branchPathName\n</code></pre></p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/overview/","title":"Credential Wallet Overview","text":"<p>The Credential Wallet lets a user fetch credentials from the Issuer and save these credentials to his/her wallet. These credentials are later used to prove his/her identification to a Verifier. Once the credentials have been fetched and stored, a user can, later, retrieve them from the database, can update them, or delete them altogether. The credentials have unique IDs that let a user access them seamlessly. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/fetch-and-save-claims/","title":"To Fetch and Save Credentials: <code>fetchAndSaveClaims</code>","text":"<p>An Integrator can fetch credentials stored on an Issuer and then save them in his/her wallet. The<code>fetchAndSaveClaims()</code> function is called to fetch and save a list of credentials from an Issuer.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/fetch-and-save-claims/#fetch-and-save-credentials","title":"Fetch and Save Credentials","text":"<pre><code>Future&lt;List&lt;ClaimEntity&gt;&gt; fetchAndSaveClaims(\n      {required OfferIden3MessageEntity message,\n      required String did,\n      required String privateKey});\n</code></pre> <p>The <code>fetchAndSaveClaims()</code> function uses <code>OfferIden3MessageEntity</code>, <code>privateKey</code>, and <code>did</code> as the input parameters. and returns a list of <code>ClaimEntity</code>.</p> <p><code>OfferIden3MessageEntity</code>: OfferIden3MessageEntity is a type of <code>Iden3MessageEntity</code>. As you saw in the iden3 Message API tutorial, we get <code>Iden3MessageEntity</code> when we call <code>getIden3Message()</code>method. </p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>did</code> is the unique id of the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/fetch-and-save-claims/#wallet-issuer-interaction-for-fetching-credentials","title":"Wallet-Issuer Interaction for Fetching Credentials","text":"<ol> <li> <p>Integrator scans the QR code displayed on the Issuer site to get the iden3 message.</p> </li> <li> <p>The Integrator uses the <code>OfferIden3MessageEntity</code> obtained from the iden3 message to authenticate and fetch the credentials from the Issuer.</p> </li> <li> <p>The Issuer validates the identity and returns a list of <code>ClaimEntities</code> back to the Integrator.</p> </li> <li> <p>The credentials are stored on the SDK associated with the identity.</p> </li> </ol> <p></p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/","title":"Get Claims","text":"<p># To Get Credentials: <code>getClaims</code> </p> <p>After a credential is fetched from an Issuer and stored on the wallet SDK, an Integrator can retrieve this credential from the storage. This is done using <code>getClaims()</code> function.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/#get-credentials","title":"Get Credentials","text":"<pre><code>Future&lt;List&lt;ClaimEntity&gt;&gt; getClaims(\n      {List&lt;FilterEntity&gt;? filters,\n      required String did,\n      required String privateKey});\n</code></pre> <p>This function returns a list of <code>ClaimEntity</code> based on some pre-defined criteria or filters. The function uses <code>privateKey</code> and <code>did</code> as input parameters.</p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>did</code> is the unique id of the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/#get-credentials-by-ids-getclaimsbyids","title":"Get Credentials by Ids: <code>getClaimsByIds</code>","text":"<p>The <code>getClaimsByIds()</code> function retrieves a list of credentials stored on the SDK using a list of credential ids.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/get-claims/#get-credentials-by-ids","title":"Get Credentials by Ids","text":"<pre><code>Future&lt;List&lt;ClaimEntity&gt;&gt; getClaimsByIds(\n      {required List&lt;String&gt; claimIds,\n      required String did,\n      required String privateKey});\n</code></pre> <p>The method, based on the credential ids, retrieves a list of <code>ClaimEntity</code> from the storage. </p> <p>Note: An Issuer assigns ids to the credentials. The wallet, after fetching these credentials, stores them on the SDK. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/remove-claims/","title":"To Remove Claims: 'removeClaims'","text":"<p>The credentials stored on the SDK storage can be removed locally (they remain on the Issuer unless removed by it) by the Integrator. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/remove-claims/#remove-credentials","title":"Remove Credentials","text":"<p>The <code>removeClaims()</code> method, which removes credentials from the storage based on a list of <code>claimIds</code>:</p> <p><pre><code>Future&lt;void&gt; removeClaims({required List&lt;String&gt; claimIds,\n      required String did,\n      required String privateKey});\n</code></pre> <code>claimids</code> are the ids of the credentials. </p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>did</code> is the unique id of the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/remove-claims/#to-remove-a-credential-removeclaim","title":"To Remove a Credential: 'removeClaim'","text":"<p>A single credential can also be removed from the storage based on its credential id. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/remove-claims/#remove-a-single-credential","title":"Remove a Single Credential","text":"<p>The <code>removeClaim()</code> method, just like <code>removeClaims()</code> method, removes a single credential based on credential's id. </p> <pre><code>Future&lt;void&gt; removeClaim(\n      {required String claimId,\n      required String did,\n      required String privateKey});\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/update-claims/","title":"To Update Credentials: <code>updateClaim</code>","text":"<p>The credentials stored on the SDK can be updated using the credential's id.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/credential/api/update-claims/#update-credentials","title":"Update Credentials","text":"<p>The <code>updateClaim()</code> method uses <code>claimId</code>, <code>issuer</code>, <code>did</code>, <code>state</code>, <code>expiration</code>, <code>type</code>, <code>date</code>, and <code>privateKey</code> as input parameters and updates the credential information. </p> <p><pre><code>Future&lt;ClaimEntity&gt; updateClaim({\n    required String claimId,\n    String? issuer,\n    required String did,\n    ClaimState? state,\n    String? expiration,\n    String? type,\n    Map&lt;String, dynamic&gt;? data,\n    required String privateKey,\n  });\n</code></pre> where:</p> <p><code>claimId</code> is the credential's id.</p> <p><code>issuer</code> is the <code>did</code> of the issuer.</p> <p><code>did</code> is the unique id of the identity.</p> <p><code>state</code> is the credential's current state.</p> <p><code>expiration</code> is the date and time of the expiration of the credential in string format.</p> <p><code>type</code> is type of verifiable credential, for example: KYCAgeCredential.</p> <p><code>data</code> is the information related to a verifiable credential.</p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity.  </p> <p>This function returns the updated <code>ClaimEntity</code>.</p> <p>Note: Only the <code>ClaimEntity.info</code> is updated and <code>data</code> is subject to validation by the data layer. <code>ClaimEntity.info</code> is the information related to a verifiable credential that an Integrator receives from an Issuer. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/","title":"Type of Authorization Requests","text":"<p>The proof generation by the wallet SDK is based on two types of authorization requests sent by the Verifier (or also by the Issuer in the case of Basic Auth):</p> <ul> <li>Based on <code>Basic Auth</code> Requests</li> <li>Based on <code>Query-based</code> Requests</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#basic-auth-request","title":"Basic Auth Request","text":"<p>The Issuer/Verifier sends the <code>Basic Auth</code> request to the wallet when wallet needs to prove its identity (based on the Identifier generated earlier) to the Issuer/Verifier. This request is sent when an Identity needs to prove that it is, indeed, what it asserts to be. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#structure-of-basic-auth-request","title":"Structure of Basic Auth Request","text":"<p>The structure of a <code>Basic Auth</code> request can be seen below:</p> <p><pre><code>{\n\"id\": \"6c004daa-b664-4c1a-8393-66ef6755a07b\",\n\"thid\": \"6c004daa-b664-4c1a-8393-66ef6755a07b\",\n\"from\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/authorization/1.0/request\",\n\"body\": {\n\"reason\": \"test flow\",\n\"message\": \"\",\n\"callbackUrl\": \"https://verifier.polygonid.me/api/callback?sessionId=95209\",\n\"scope\":\n}\n}\n</code></pre> Note: The details of each of the fields of the request can be seen in the section below on Query Request.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#query-based-request","title":"Query-based Request","text":"<p>A Query-Based Request is used for generating two types of proofs: Signature-based Proof and Merkle Tree Proof (MTP). For such proofs, we have a credential that satisfies pre-determined criteria (as can be seen from the structure of the Query-based Request below) and these credentials are used for generating the proofs and shared with the Verifier using <code>callbackUrl</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#structure-of-query-based-request","title":"Structure of Query-based Request","text":"<p><pre><code>{\n\"id\": \"b5d9edf2-adcf-4600-b273-1f6f32da87ee\",\n\"thid\": \"b5d9edf2-adcf-4600-b273-1f6f32da87ee\",\n\"from\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/authorization/1.0/request\",\n\"body\": {\n\"reason\": \"test flow\",\n\"message\": \"\",\n\"callbackUrl\": \"https://verifier.polygonid.me/api/callback?sessionId=932469\",\n\"scope\": {\n\"0\": {\n\"id\": \"1\",\n\"circuit_id\": \"credentialAtomicQuerySig\",\n\"rules\": {\n\"query\": {\n\"allowedIssuers\":\n\"0\": \"*\",\n\"schema\": {\n\"type\": \"KYCAgeCredential\",\n\"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\"\n},\n\"req\": {\n\"birthday\": {\n\"$lt\": \"20000101\"\n}\n}\n}\n}\n}\n}\n}\n}\n</code></pre> where:</p> <ul> <li>id: Identifier stored on the wallet SDK</li> <li>thid: Id of the message thread</li> <li>from: from where the authentication request comes, i.e. the identifier of the identity from which a Verifier requests proof</li> <li>typ: iden3comm Media Type, i.e. File format for the type field. (For example, JSON)</li> <li>type: Type of iden3comm Protocol Message; type of request; it could be an auth request, proof request, or a credential offer</li> <li>reason: reason of authentication (it could be age verification or simply a test flow)</li> <li>message: Message to be signed; can be left blank</li> <li>callbackUrl: URL to which requested information is sent and response is received</li> <li>scope: information related to the proof request and the requirements to be fulfilled by the proof generated and shared from mobile. It is in the form of an array of proofs that the SDK generates.</li> <li>0:</li> <li>id: Scope id</li> <li>circuit_id: Type of proof; in the above example, it is credentialAtomicQuerySig.</li> <li>rules:</li> <li>query:</li> <li>allowedissuers: types of Issuers allowed</li> <li>0: \"*\" : All types of Issuers are allowed</li> <li>schema: A structure that is used for proof generation for a credential</li> <li>type: Type of credentials allowed</li> <li>url: url for getting the vocabulary for the credential</li> <li>req: A query request to a query circuit; for example, the user's birthday should fall before January 1, 2000</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#difference-between-basic-auth-and-query-based-requests","title":"Difference Between <code>Basic Auth</code> and <code>Query-based</code> Requests","text":"<p>The difference between the proofs based on <code>Basic Auth</code> and <code>Query-based</code> requests is that the <code>Basic Auth</code> is used by an identity for authenticating itself (as was mentioned above) and the <code>Query-based</code> is used for authenticating the credentials that the Identity receives from an Issuer.</p> <p>The fundamental structure of the request types is the same except that the <code>Query-based request</code> carries more parameters: in the form of more information linked to the proof generated by the wallet SDK; it includes information such as type of credentials allowed, URL for getting vocabulary for those credential and requirements that a credential must satisfy (ex, the birth date should be more than 18).</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#auth-circuit-and-atomicquerysig-circuit","title":"Auth Circuit and AtomicQuerySig Circuit","text":"<p>A circuit is zero-knowledge based program that generates a zk proof based on a set of inputs provided. An <code>Auth Circuit</code> creates a proof for the <code>Basic Auth</code> requests and <code>AtomicQuerySig Circuit</code> generates proof for signature-based requests <code>AtomicQueryMTP</code> is used for the MTP-based requests.</p> <p>For more information on circuits, go through the following links:</p> <p>auth circom</p> <p>credentialAtomicQuerySig</p> <p>circomcredentialAtomicQueryMTP</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/#how-is-proof-sent-to-the-verifier","title":"How is Proof sent to the Verifier?","text":"<p>The wallet sends the proof generated to a Verifier using a <code>callbackUrl</code>; this URL is included in the auth request and includes the information that the Verifier requests from the Wallet. So, the Wallet sends the proof request along with the credential via this <code>callbackUrl</code> and receives the proof response from the Verifier on the same URL.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/","title":"JWZ - JSON Web Zero Knowledge","text":"<p>JSON Web Zero-knowledge (JWZ) is an open standard for representing messages proven with zero-knowledge technology.</p> <p>Based on the existing secure messaging standards, namely, JWM (JSON Web Message) and JWT (JSON Web Token), JWZ is a standard format for representing and sending secure messages backed by zero-knowledge technology. It is a novel way of providing interaction between two parties that intend to exchange messages while keeping the sender's public keys hidden. The proof that the wallet generates is packed in the JWZ format and sent to the Verifier using <code>callbackUrl</code>.</p> <p>In the Iden3 Protocol, JWZ is the core primitive to manage communications between different parties. A JWZ expands the signature schema of the popular JWT standard.</p> <p>Any message can be packed inside a JWZ while the proof guarantees data integrity and provenance of the message, providing helpful metadata among the message.</p> <p>JWZ</p> <p>This is an example of a JWZ generated by an identity wallet as a response to the auth request generated as a response to a zk request posed by a Verifier, similar to the one performed inside the Verifier Setup Tutorial.</p> <p>JWZ consists of three parts separated by a dot (.):</p> <ul> <li>Header</li> <li>Payload message</li> <li>Proof</li> </ul> <p><code>eyJhbGciOiJncm90aDE2IiwiY2lyY3VpdElkIjoiYXV0aFYyIiwiY3JpdCI6WyJjaXJjdWl0SWQiXSwidHlwIjoiYXBwbGljYXRpb24vaWRlbjMtemtwLWpzb24ifQ.eyJpZCI6IjVlOWZmMGJiLTk1NzctNDNiNS1iZWZlLWQxMWNlMDRkYzZlMiIsInR5cCI6ImFwcGxpY2F0aW9uL2lkZW4zY29tbS1wbGFpbi1qc29uIiwidHlwZSI6Imh0dHBzOi8vaWRlbjMtY29tbXVuaWNhdGlvbi5pby9hdXRob3JpemF0aW9uLzEuMC9yZXNwb25zZSIsInRoaWQiOiI3ZjM4YTE5My0wOTE4LTRhNDgtOWZhYy0zNmFkZmRiOGI1NDIiLCJmcm9tIjoiZGlkOnBvbHlnb25pZDpwb2x5Z29uOm11bWJhaToycU1ZN3h5bWFYV2RGRHQ3NHhSMXo4bVlyelNZQkMxVmVTV3c2WmhjU1AiLCJ0byI6ImRpZDpwb2x5Z29uaWQ6cG9seWdvbjptdW1iYWk6MnFEeXkxa0VvMkFZY1AzUlQ0WEdlYTdCdHhzWTI4NXN6ZzZ5UDlTUHJzIiwiYm9keSI6eyJkaWRfZG9jIjp7IkBjb250ZXh0IjpbImh0dHBzOi8vd3d3LnczLm9yZy9ucy9kaWQvdjEiXSwiaWQiOiJkaWQ6cG9seWdvbmlkOnBvbHlnb246bXVtYmFpOjJxTVk3eHltYVhXZEZEdDc0eFIxejhtWXJ6U1lCQzFWZVNXdzZaaGNTUCIsInNlcnZpY2UiOlt7ImlkIjoiZGlkOnBvbHlnb25pZDpwb2x5Z29uOm11bWJhaToycU1ZN3h5bWFYV2RGRHQ3NHhSMXo4bVlyelNZQkMxVmVTV3c2WmhjU1AjcHVzaCIsInR5cGUiOiJwdXNoLW5vdGlmaWNhdGlvbiIsInNlcnZpY2VFbmRwb2ludCI6Imh0dHBzOi8vcHVzaC1zdGFnaW5nLnBvbHlnb25pZC5jb20vYXBpL3YxIiwibWV0YWRhdGEiOnsiZGV2aWNlcyI6W3siY2lwaGVydGV4dCI6IllleWRnWnBWRXVFRFM5VnV6OEhGL0lVWDJFUS9admxWZjZHYWVJZWJVQ005SGc1bk5maHZhZEpjL0JMd25GejJEK1l0L29vMkdEYnpjZittcEpOcCt4di9Zb2dxbjl0Q3lJVU9icTdJYVpJdUVTZXhoL1VhdCtTZnZHODdJSks1M0hKR1JJTHU4VzF3SHdVeVFZeGR5YUtCaWtmTnRZajdZdFdNS0dXUTVSNnlwWnFBUG8rZjQzNUtjZ3B4R1EybVRMNHRNMmpWRWxaZjlVTVhEeDl1b0QrdU9sbzJQb2hIamNnUDNLZDVqYVNsZmV2T0ZMc0JGVmFseWVzbWNjMldqYzU4KzVDTUxabm5tSkU0Vkl3Q1Nwd1NOb2ZNM1FvREEyOHA0eVR1ay9VaHhUbUNzSVNMN3hyNkRCa3MzN3NyUmpUNkF0QU90QkZKTXljZk5JUFAvd1ROSUVmanp3VXN3Vlg2Zmpzd2tYbmtScWQ5QWVlK1U0Y25jSFMvdWw4U21DLzhpNGx2b083KzhHTjE1TlJaTk1oV2tNL0RNSVMrRVNWYnhCTVdJSWJUWktFbVErWXRERGJhMEI4R09OSU92Zi93eDhoU1IxL1NwTCtFMDhXTDU4UmlKWTNuUFhvS0dZK1RtQlplM2UwdklVS2pzcUpVRmhhUG91MUlxa2E2QU9PTXVuNWxaMUQvNVBnb2YvOTFOWTdIYzd5TXA4Wjd4a1VJZEhEa216U3VrSk5XTjNvV2VYVURsZDdFUkV4Ym4zZ2xYSEVLRjFkZzVJRm4rejIvV0xJbnFlSGpZa2xrOE8rdnh6YlZpSUVWWkM0TXErUG1EMDU4Nk9qdklQTlZhWkpaMllUZmlJRmZJUUh5Y2hoaEhOVDFTdko3TnRXaG1RMHZFc2tJY3JBPSIsImFsZyI6IlJTQS1PQUVQLTUxMiJ9XX19XX0sIm1lc3NhZ2UiOm51bGwsInNjb3BlIjpbeyJpZCI6MSwiY2lyY3VpdElkIjoiY3JlZGVudGlhbEF0b21pY1F1ZXJ5U2lnVjIiLCJwcm9vZiI6eyJwaV9hIjpbIjE1ODg0MTQzNjg5MTg2NTYwNzcwNjEzMjc3NTg1Mzk0NzkwMzM5ODMzMjE2NTUxMzM0NDU1MjU5MDU3MTA0NjI1MzMwMDcyNTM0NTEzIiwiMzI3OTA4NzYxMjAyMjcxMjAwMjM0NjI0NjQ0OTExOTM4MjkxMTYyNjAyMDEwNjA0MzQxNDc5ODUzODc5Njk4MzIwNDYyNTU2MTYyNyIsIjEiXSwicGlfYiI6W1siMTc0ODM4Mjc4OTMzNjMwMDgzNTk2NzcxOTc3NTY1ODg3MjU4NzQ4NDc3Nzg3Mzk4OTkzNzAzNDc0MTg4MzIxMDA0ODg4OTQ4NjI1OTIiLCIxODU4MTk5MDQwNDk2MTY2MjM3NTQ2ODg5NTE1NTA2MzM1MjI1Mjk3NzQwNDc0NDExNjU5MDIzNDcxNDMyNjkxNjc4NTg1ODgzNTk2NiJdLFsiMTUwNTY0NjYxMzIxNjMxNzkwNTYzNTY3NDg1NDgxMDM1ODEyMzgwNjU4Nzg3NjM2OTQ5MTE4NjE0NjM4MTI2NzE3NTUyNzM5ODQxNDkiLCI3NDQ4NDU1Mjg5ODEwMTI4MTY1NTUzOTU2Mjc1MDc3NzI2MDQyNDc4OTc0NzY0NzMwMjMxNTY0Mzg5Njc0MTU5NDAwNDgwMTI5ODYiXSxbIjEiLCIwIl1dLCJwaV9jIjpbIjI4NDA0NjIyNTU5OTA5MjM1NjE5MzU1NzU2NjUyNDY5ODY3MDM0MjQyMTc1MzA0NDIzOTUxMzY4NzY4Njg4MTYyOTk5NzkyOTI1NzQiLCI3OTM0MDU2NjA1MTcyNjU4MTQ5MjEyNzAyMzE2NDIxNTg5OTk0ODgyMDIwMjUxMzM1OTkxNDU1OTE3NzI0ODkwMzI1Mjk3MjM4MjM4IiwiMSJdLCJwcm90b2NvbCI6Imdyb3RoMTYiLCJjdXJ2ZSI6ImJuMTI4In0sInB1Yl9zaWduYWxzIjpbIjEiLCIyMTk5NjMxNzg0MzA2ODkxOTQyNTkwMDI4NDIwODg5Mjg3MTIzMzkwMDY5NjI3OTk4MDY5NTYwMjYxMjY4NjQ4OTAxMjA4MTE1NCIsIjIxMjA1MDIxNTQyNzU2Nzc3MDE2ODYwNDY5MTkxMzg1OTAwMTY0MTM1MzQwNDA4NzU2NDY1MDY4MTU4MDY5NTQ3NjQxMDcxMTc3NDk0IiwiMSIsIjI0ODI2ODQ1NTI3MTgyMTY4NDY2NzgyNjcwODI4NDI4Mzc1MTUxNjU2NjQzNzU5MTc0MjE5Njg2Njg2ODE5MDYxMzk5MTYzMzk0IiwiMSIsIjc1NDU4NTYwNzQ3MDMxNDU4OTQ4NjUyMTM5NzcwNTIzMjA4ODMyNTI0MjYzOTc2NTYxMjIwNTkxMzQ3NDI1NTk4NzU5OTU5MjUwMzEiLCIxNjc1MzMwOTk0IiwiNzQ5NzczMjc2MDA4NDgyMzEzODU2NjMyODAxODE0NzYzMDc2NTciLCIwIiwiMjAzNzYwMzM4MzIzNzExMDkxNzc2ODMwNDg0NTYwMTQ1MjU5MDUxMTkxNzM2NzQ5ODU4NDM5MTU0NDU2MzQ3MjYxNjc0NTA5ODk2MzAiLCIwIiwiMiIsIjIwMDAwMTAxIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIiwiMCIsIjAiLCIwIl19XX19.eyJwcm9vZiI6eyJwaV9hIjpbIjEwMjk0NzY4MzQ5NzcxOTAwMjgwNjcyMTQzMjkwMDM2MDk0Mjg5OTgyODM2OTU1MDMwMDQwMzE3MjA5NTcxMDQ2NDY5MTgzNDM2NjUwIiwiODQ2NjE1MjIxMzA3NDA2MTMxNDU5NjE5MTcxODAzNjIzMzgyNjEwMjAyMDg0NzM4NTMxMDY3NDg2ODgxODY1OTIyNjIwNDQxNDU2NyIsIjEiXSwicGlfYiI6W1siMTEyMTg5ODIxMDk0Njc1NTU0MDExMDI5ODM5MTc5OTk3OTYyOTc1MjI1MjI2NDI4ODE0Njg3MTkyNTYwMTk0Mzc4NDU4OTQ2OTU4OTAiLCIyMDM0MDI5NzIxOTA1MDgyNDQyNjk1OTQ5OTQ4NDc5MTA5NzAyNDkyMTIxNjI4MzE0ODU4ODEwNTE3NjEyMDU4MzgxNTM2NDg0NTMxMSJdLFsiNDM5NDQ5OTc4MTY2OTE4ODI4Mjc2MzM3NTc2ODE2MTM2NzQwODQ0Mzk4NjY5NTM4ODU3MTcwNDgxNDYxNjI4Njg5ODgwNTM2ODYzOCIsIjExOTEwNjE0NTczMDM3MDUzMzkxODc3OTMzMTU0MjQ0MzM3ODcxOTE1Nzc5MDAzMDkwMzA0OTYxNzM0NjAzNzUxNzEzNTI5NzY4NCJdLFsiMSIsIjAiXV0sInBpX2MiOlsiMjA3Mjk5MjA5MTI3ODE3NDA2MDM5NTQ4OTExNTY2NDkwMDY1MjQzMzE5NzEwNjg4NjQxNzQwMTYyNjYwMDQ5MDUwMTYwNjExNjUzMDMiLCIxMjI0NjMxMzI0NDQxMjIyMzE3NDMwNTQzNjQzOTI2MDk0MjgzMTI5MzA3MTA4MTkzNTYyOTUzMjIzODI3MTgzNDE0MDk3NTE4MTkwNiIsIjEiXSwicHJvdG9jb2wiOiJncm90aDE2IiwiY3VydmUiOiJibjEyOCJ9LCJwdWJfc2lnbmFscyI6WyIyMTk5NjMxNzg0MzA2ODkxOTQyNTkwMDI4NDIwODg5Mjg3MTIzMzkwMDY5NjI3OTk4MDY5NTYwMjYxMjY4NjQ4OTAxMjA4MTE1NCIsIjg2MTgzNjg2NzI2ODA1NTk5NTYxMTc4Mjg4NzI3MzY4OTI4NDY1OTQ2NjIyNDQ4Njc4NjcwMDIyNTkwNjMxNjM5MTk4MzE5MzU1OTIiLCI1MTUzMzUwNDEyMTg5NjMwNzkwNDk5NzAxMTA3MTc1NDc1MjgxNDY1MjQ2NDY3MTc3MzY5NjYyMTE3OTAzNTY1NjUzMDc2NjY4MDIzIl19</code></p> <p>Each part of the token can be parsed into a human-readable string by base 64 decoding.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#header","title":"Header","text":"<p>Defines the feature of the token.</p> <pre><code>{\n\"alg\": \"groth16\",\n\"circuitId\": \"authV2\",\n\"crit\": [\n\"circuitId\"\n],\n\"typ\": \"application/iden3-zkp-json\"\n}\n</code></pre> <p>alg - is a zero-knowledge algorithm that is used for proof generation.</p> <p>circuitId - is a circuit that is used for proof generation. For authentication - auth circuit must be used.</p> <p>crit - describes the list of header keys that the verifier must support. </p> <p>typ - is the media type of the message. In our case, it is the type of the protocol of the packed message application/iden3-zkp-json.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#payload-message","title":"Payload Message","text":"<p>Contains the message that needs to be shared with another party.</p> <p>In this example, the message is the proof related to the query analysed previously. However, any type of message can be included in the payload. </p> <pre><code>{\n\"id\": \"5e9ff0bb-9577-43b5-befe-d11ce04dc6e2\",\n\"typ\": \"application/iden3comm-plain-json\",\n\"type\": \"https://iden3-communication.io/authorization/1.0/response\",\n\"thid\": \"7f38a193-0918-4a48-9fac-36adfdb8b542\",\n\"from\": \"did:polygonid:polygon:mumbai:2qMY7xymaXWdFDt74xR1z8mYrzSYBC1VeSWw6ZhcSP\",\n\"to\": \"did:polygonid:polygon:mumbai:2qDyy1kEo2AYcP3RT4XGea7BtxsY285szg6yP9SPrs\",\n\"body\": {\n\"did_doc\": {\n\"@context\": [\n\"https://www.w3.org/ns/did/v1\"\n],\n\"id\": \"did:polygonid:polygon:mumbai:2qMY7xymaXWdFDt74xR1z8mYrzSYBC1VeSWw6ZhcSP\",\n\"service\": [\n{\n\"id\": \"did:polygonid:polygon:mumbai:2qMY7xymaXWdFDt74xR1z8mYrzSYBC1VeSWw6ZhcSP#push\",\n\"type\": \"push-notification\",\n\"serviceEndpoint\": \"https://push-staging.polygonid.com/api/v1\",\n\"metadata\": {\n\"devices\": [\n{\n\"ciphertext\": \"YeydgZpVEuEDS9Vuz8HF/IUX2EQ/ZvlVf6GaeIebUCM9Hg5nNfhvadJc/BLwnFz2D+Yt/oo2GDbzcf+mpJNp+xv/Yogqn9tCyIUObq7IaZIuESexh/Uat+SfvG87IJK53HJGRILu8W1wHwUyQYxdyaKBikfNtYj7YtWMKGWQ5R6ypZqAPo+f435KcgpxGQ2mTL4tM2jVElZf9UMXDx9uoD+uOlo2PohHjcgP3Kd5jaSlfevOFLsBFValyesmcc2Wjc58+5CMLZnnmJE4VIwCSpwSNofM3QoDA28p4yTuk/UhxTmCsISL7xr6DBks37srRjT6AtAOtBFJMycfNIPP/wTNIEfjzwUswVX6fjswkXnkRqd9Aee+U4cncHS/ul8SmC/8i4lvoO7+8GN15NRZNMhWkM/DMIS+ESVbxBMWIIbTZKEmQ+YtDDba0B8GONIOvf/wx8hSR1/SpL+E08WL58RiJY3nPXoKGY+TmBZe3e0vIUKjsqJUFhaPou1Iqka6AOOMun5lZ1D/5Pgof/91NY7Hc7yMp8Z7xkUIdHDkmzSukJNWN3oWeXUDld7ERExbn3glXHEKF1dg5IFn+z2/WLInqeHjYklk8O+vxzbViIEVZC4Mq+PmD0586OjvIPNVaZJZ2YTfiIFfIQHychhhHNT1SvJ7NtWhmQ0vEskIcrA=\",\n\"alg\": \"RSA-OAEP-512\"\n}\n]\n}\n}\n]\n},\n\"message\": null,\n\"scope\": [\n{\n\"id\": 1,\n\"circuitId\": \"credentialAtomicQuerySigV2\",\n\"proof\": {\n\"pi_a\": [\n\"15884143689186560770613277585394790339833216551334455259057104625330072534513\",\n\"3279087612022712002346246449119382911626020106043414798538796983204625561627\",\n\"1\"\n],\n\"pi_b\": [\n[\n\"17483827893363008359677197756588725874847778739899370347418832100488894862592\",\n\"18581990404961662375468895155063352252977404744116590234714326916785858835966\"\n],\n[\n\"15056466132163179056356748548103581238065878763694911861463812671755273984149\",\n\"744845528981012816555395627507772604247897476473023156438967415940048012986\"\n],\n[\n\"1\",\n\"0\"\n]\n],\n\"pi_c\": [\n\"2840462255990923561935575665246986703424217530442395136876868816299979292574\",\n\"7934056605172658149212702316421589994882020251335991455917724890325297238238\",\n\"1\"\n],\n\"protocol\": \"groth16\",\n\"curve\": \"bn128\"\n},\n\"pub_signals\": [\n\"1\",\n\"21996317843068919425900284208892871233900696279980695602612686489012081154\",\n\"21205021542756777016860469191385900164135340408756465068158069547641071177494\",\n\"1\",\n\"24826845527182168466782670828428375151656643759174219686686819061399163394\",\n\"1\",\n\"7545856074703145894865213977052320883252426397656122059134742559875995925031\",\n\"1675330994\",\n\"74977327600848231385663280181476307657\",\n\"0\",\n\"20376033832371109177683048456014525905119173674985843915445634726167450989630\",\n\"0\",\n\"2\",\n\"20000101\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\",\n\"0\"\n]\n}\n]\n}\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#signature","title":"Signature","text":"<p>It represents a ZK authentication proof based on the <code>auth circuit</code>.</p> <pre><code>{\n\"proof\": {\n\"pi_a\": [\n\"10294768349771900280672143290036094289982836955030040317209571046469183436650\",\n\"8466152213074061314596191718036233826102020847385310674868818659226204414567\",\n\"1\"\n],\n\"pi_b\": [\n[\n\"11218982109467555401102983917999796297522522642881468719256019437845894695890\",\n\"20340297219050824426959499484791097024921216283148588105176120583815364845311\"\n],\n[\n\"4394499781669188282763375768161367408443986695388571704814616286898805368638\",\n\"119106145730370533918779331542443378719157790030903049617346037517135297684\"\n],\n[\n\"1\",\n\"0\"\n]\n],\n\"pi_c\": [\n\"20729920912781740603954891156649006524331971068864174016266004905016061165303\",\n\"12246313244412223174305436439260942831293071081935629532238271834140975181906\",\n\"1\"\n],\n\"protocol\": \"groth16\",\n\"curve\": \"bn128\"\n},\n\"pub_signals\": [\n\"21996317843068919425900284208892871233900696279980695602612686489012081154\",\n\"8618368672680559956117828872736892846594662244867867002259063163919831935592\",\n\"5153350412189630790499701107175475281465246467177369662117903565653076668023\"\n]\n}\n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#difference-between-jwt-and-jwz","title":"Difference between JWT and JWZ","text":"<p>JWT relies on digital signatures for the secure transmission of information. In particular, \"JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA\". (JWT.io). In JWZ, this signature is performed with zero-knowledge. In particular:</p> <ul> <li>The <code>header</code> and the <code>payload</code> get hashed together using the Poseidon hash.</li> <li>The JWZ initiator signs the hashed content using his/her private key.</li> <li>The JWZ creator generates a proof using the authorization circuit to demonstrate that his/her identity signed the content.</li> <li>The proof gets included in the <code>zero- knowledge proof</code> of the JWZ together with the public inputs used inside the circuit to generate the proof.</li> <li>Any third party that accesses the JWZ can verify the proof to check if the information contained in the payload actually originated from that identity and hasn't been tampered with.</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#usage","title":"Usage","text":"<p>JWZ represents the main instrument to communicate securely between parties off-chain. This data primitive integrates seamlessly within web2 architectures for authentication purposes. </p> <p>Here, we used the JWZ to manage the communication between the user and the Verifier. A JWZ can also be used in the communication between the user and the Issuer so that the user can prove his/her identity in order to fetch the claims associated with his/her identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/jwz/#libraries","title":"Libraries","text":"<ul> <li>js-jwz for JavaScript implementation</li> <li>go-jwz for Go implementation</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/overview/","title":"Iden3comm Overview","text":"<p>Iden3comm is the protocol that defines the set of rules and syntax of the data that needs to be communicated while interacting with an Issuer and a Verifier. The protocol lays down the foundation for the semantics and the synchronization that is involved during the communication between two parties.   </p> <p>The Iden3comm protocol defines the structure of the messages, requests, and responses that are quintessential for the exchange of information between the Identity Holder, the Issuer, and the Verifier. It handles the following types of messages, requests, and responses between the entities involved in the communication process:</p> <ul> <li>Authorization Request Messages and Response Body</li> <li>Authorization Response Messages and Response Body</li> <li>Zero-knowledge  Proof Requests and Responses</li> <li>Credential Request Messages for Credential Issuance and Credential Fetching</li> <li>Credential Response Messages for Credential Issuance</li> <li>Iden3 Messages for Message Fetch Requests</li> <li>Revocation Status Request Messages</li> <li>Device Registration Requests</li> </ul> <p></p> <p>For more details on the structure of each type of message, click Iden3comm Protocol.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/","title":"To Authenticate Identity with Issuer","text":"<p>An Integrator, in order to use the services of an Issuer, needs to authenticate itself with that Issuer. For this to happen, the Integrator needs to call the <code>authenticate()</code> method. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/#authenticate-identity","title":"Authenticate Identity","text":"<p>The <code>authenticate()</code> method uses  <code>Iden3MessageEntity</code>, <code>did</code>, <code>profileNonce</code>, <code>privateKey</code>, and an optional <code>pushToken</code> as input parameters.</p> <p><pre><code>Future&lt;void&gt; authenticate(\n      {required Iden3MessageEntity message,\n      required String did,\n      int? profileNonce,\n      required String privateKey,\n      String? pushToken});\n</code></pre> <code>Iden3MessageEntity</code> is the iden3 message retrieved from the <code>getIden3Message()</code> method <code>did</code> is the unique id of the identity. <code>profileNonce</code> is the nonce of the profile of an identity.  <code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>pushToken</code> lets an Integrator receive the iden3 messages through push notification.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/#steps","title":"Steps","text":"<ol> <li> <p>Retrieve <code>CircuitDataEntity</code> from the loadCircuitFiles. <code>CircuitDataEntity</code> are the circuits used for generating an authentication proof that we share with the Issuer with JWZ.</p> </li> <li> <p>Retrieve iden3message by scanning the QR code and transform it as a string message with <code>getiden3message()</code> method. </p> </li> <li> <p>Get authToken from authenticate() and authenticate Identity with authToken.</p> </li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/authenticate/#wallet-issuer-interaction-using-authentication","title":"Wallet-Issuer Interaction using Authentication","text":"<p>An Integrator, to interact with an Issuer, needs to authenticate with it first. </p> <ol> <li> <p>On the Polygon ID app (which is based on SDK), an Integrator clicks Connect.</p> <p> </p> </li> <li> <p>The Issuer displays a QR code. The Integrator, using the app, scans this code.</p> <p> </p> </li> <li> <p>With this, the <code>Authenticate()</code> function (with the identifier, private key and message as the inputs) is executed. The function authenticates the Identity and sends the authentication information (in the form of a big encoded message based on JWZ) to the Issuer.</p> <p> </p> <p>Note: Read more on JWZ here.</p> </li> <li> <p>The Issuer receives the data sent by the Integrator and based on its correctness, authenticates or rejects the identity. The wallet analyzes this response from the Issuer.</p> </li> </ol>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-proofs/","title":"To Get Proofs: <code>getProofs</code>","text":"<p>This function uses identity to generate the zero-knowledge proofs requested by the <code>Iden3Message Entity</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-proofs/#get-proof","title":"Get Proof","text":"<p>The <code>getProofs()</code> method uses <code>Iden3MessageEntity</code>, <code>did</code>, <code>profileNonce</code>, and <code>privateKey</code> as the input parameters and returns a <code>JWZProofEntity</code>.</p> <pre><code>Future&lt;List&lt;JWZProofEntity&gt;&gt; getProofs(\n      {required Iden3MessageEntity message,\n      required String did,\n      int? profileNonce,\n      required String privateKey}); \n</code></pre> <p><code>Iden3MessageEntity</code>: Returned from <code>getIden3Message</code> method after a user scans the QR code on Issuer/Verifier website. </p> <p><code>profileNonce</code> is the nonce of the profile of an identity.</p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>did</code> is the unique id of the identity. </p> <p><code>JWZProofEntity</code>is the JWZ message that the Integrator sends to the Issuer/Verifier after scanning the QR code. Read more about JWZ here.</p> <p>Note: The iden3comm's <code>getProofs</code> method retrieves the proofs from the proof request of the Verifier. The actual proof is created by the <code>prove()</code> method, which you will read about in the Proof section of the APIs.  For this to happen, iden3comm makes a call to <code>prove</code>().</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-vocabs/","title":"To Get Vocabs: <code>getVocabsFromIden3Message</code>","text":"<p>It gets the vocabulary json-ld files to translate the values of the schemas to be used by Integrators in a human-readable form in their apps.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/get-vocabs/#get-vocabulary","title":"Get Vocabulary","text":"<p>The <code>getVocabsFromIden3Message()</code> method uses <code>Iden3MessageEntity</code> as the input parameter and returns a list of maps of vocabulary json-ld files. </p> <pre><code>Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getVocabsFromIden3Message(\n      {required Iden3MessageEntity message}) \n</code></pre>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/iden3-message/","title":"To Get Iden3 Message: <code>getIden3Message</code>","text":"<p>All communication between SDK and Issuer/Verifier is done through an <code>Iden3MessageEntity</code>. For example, an Integrator can retrieve this iden3 message from a message string obtained from an Issuer or a Verifier after scanning a QR code. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/iden3comm/api/iden3-message/#get-iden3-message","title":"Get Iden3 Message","text":"<p>The <code>getIden3Message()</code> method uses a message String as the input parameter and returns an <code>Iden3MessageEntity</code>.</p> <pre><code>Future&lt;Iden3MessageEntity&gt; getIden3Message({required String message});\n</code></pre> <p>The <code>Iden3MessageEntity</code> is returned with different parsed parameters depending on the type of message.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/overview/","title":"Identity Wallet Overview","text":"<p>An Identity Wallet creates and stores identities for a user. A user can have more than one identity and can have several credentials linked to each identity. An Identity is represented with an Identifier which allows the user's wallet to interact with an Issuer by authenticating itself first(before the credential can be issued). </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/backup-identity/","title":"To Backup Identity: <code>backupIdentity</code>","text":"<p>This method backs up the identity stored on SDK. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/backup-identity/#backup-an-identity","title":"Backup an Identity","text":"<p>A previously stored <code>IdentityEntity</code> on SDK is backed up using <code>backupIdentity()</code> method. The <code>IdentityEntity</code> is backed up from a <code>privateKey</code> associated with the Identity. </p> <pre><code>Future&lt;Map&lt;int, String&gt;?&gt;backupIdentity({required String privateKey, required blockchain, required network}); \n</code></pre> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>blockchain</code> is the name of the blockchain associated with the identity. In our case, it is Polygon. </p> <p><code>network</code> is the type of network (Mainnet or Testnet) associated with the identity. </p> <p>The method returns a <code>map</code> of profile nonces and encrypted databases associated with the identity. </p> <p>If an error occurs, the method throws an <code>IdentityException</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/create-identity/","title":"To Create Identity: <code>createIdentity</code>","text":"<p>Creating an Identity is the first step that an Integrator needs to follow for using Polygon ID SDK. An identity is created with a unique identifier that is used to:</p> <ul> <li>Authenticate an Integrator/User</li> <li>Authenticate with the Issuer for issuing credentials to the Identity. Then these credentials are securely stored in the wallet.</li> </ul>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/create-identity/#create-an-identity","title":"Create an Identity","text":"<p>In the SDK, an identity is created using <code>createIdentity()</code> function. This is the entry point for any Integrator.</p> <p><pre><code>Future&lt;PrivateIdentityEntity&gt; createIdentity({String? secret, required blockchain, required network}); \n\n{\n    return _createIdentityUseCase.execute(\n        param: CreateIdentityParam(\n      secret: secret,\n    ));\n}\n</code></pre> The <code>createIdentity()</code> function creates and stores an <code>IdentityEntity</code> from a secret if it doesn't exist already on the Polygon ID SDK. If the secret is omitted or null, a random one will be used to create a new identity. It returns an identity as a <code>PrivateIdentityEntity</code>. It throws <code>IdentityException</code> if an error occurs.</p> <p>A <code>secret</code> is a random 32-bytes length array. An Integrator can create this secret in the way he finds it better suited for his/her application. It could be an encrypted mnemonic seed phrase generated with BIP39 (a way of creating mnemonic codes) or an Ethereum private key. If, however, no secret is passed as the input parameter, a random one can be generated. Identity's private key is derived using this secret; this secret is then hashed using keccak 256 to create the identity's private key. This private key is then used to sign the signature of a message.  </p> <p>Note: If the secret is null or omitted, the SDK creates a random one for the creation of the new identity. Depending on the length requirement of the secret string, either an Identity is successfully created or an error is displayed in form of an exception when the function is executed.</p> <p>Please note that the secret is internally converted to a 32- length bytes array in order to be compatible with the SDK. The following rules will be applied:  - If the byte array is not of length 32, it will be padded with 0s(zeroes).  - If the byte array is longer than 32, an exception will be thrown.</p> <p><code>blockchain</code> is the name of the blockchain associated with the identity. In our case, it is Polygon. </p> <p><code>network</code> is the type of network (Mainnet or Testnet) associated with the identity. </p> <p>The role of <code>createIdentity()</code> is to create a <code>PrivateIdentityEntity</code> for an Integrator and then store it on the SDK. The identifier and private key that this function generates are used by the Integrator every time it needs to interact with the Identity using the SDK. The <code>PrivateIdentityEntity</code> is created from the secret and represents an identity.</p> <p>So, in the nutshell, <code>createIdentity()</code> creates and stores an identity on the SDK and returns the <code>PrivateIdentityEntity</code> object to the integrator to be able to operate with the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-did-identifier/","title":"To Get DID Identifier: <code>getDiDIdentifier</code>","text":"<p>This function returns an identifier (identity's <code>publicKey</code>) from a <code>privateKey</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-did-identifier/#retrieve-did-identifier","title":"Retrieve DID Identifier","text":"<p><code>getDidIdentifier</code> returns a <code>did</code> Identifier using <code>privateKey</code> and <code>profileNonce</code>.</p> <p><pre><code>Future&lt;String&gt; getDidIdentifier({required String privateKey, required String blockchain, required String network, int? profileNonce}); \n</code></pre> <code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>blockchain</code> is the name of the blockchain associated with the identity. In our case, it is Polygon. </p> <p><code>network</code> is the type of network (Mainnet or Testnet) associated with the identity. </p> <p><code>profileNonce</code> is the nonce of the profile of an identity. </p> <p>Note: It is worth noting that <code>did</code> is a Decentralized Identifier associated with an identity and enables verifiable identities. A <code>did</code> could be a person, thing, organization, or even an abstract entity. The controller of the <code>did</code> can prove that it is the real owner of the identity without the need of seeking permissions/approvals from any centralized authority. </p> <p>A <code>did</code> is expressed in the following format (as per w3.org standards):</p> <p>did: did method: did method-specific identifier</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identities/","title":"Get Identities","text":"<p># To Get Identities: <code>getIdentities</code></p> <p>We can get a list of public information about all the identities stored on the SDK using <code>getIdentities()</code> function. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identities/#get-a-list-of-identities","title":"Get a List of Identities","text":"<p><pre><code>Future&lt;List&lt;IdentityEntity&gt;&gt; getIdentities();\n\n{\n   return _getIdentitiesUseCase.execute();\n\n}\n</code></pre> This method returns a list of <code>IdentityEntity</code> associated with the identities stored on the SDK. If an error occurs while retrieving the list of <code>IdentityEntity</code>, it throws <code>IdentityException</code>.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identity/","title":"To Get Identity: <code>getIdentity</code>","text":"<p>We can get an identity stored on the SDK using <code>getIdentity()</code> function. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-identity/#get-an-identity","title":"Get an Identity","text":"<pre><code>Future&lt;IdentityEntity&gt; getIdentity(\n      {required String genesisDid, String? privateKey});\n</code></pre> <p>The <code>getIdentity()</code> function gets an <code>IdentityEntity</code> from an identifier. It returns an identity as a <code>PrivateIdentityEntity</code> or <code>IdentityEntity</code> (in case <code>privateKey</code> is omitted or invalid for that identifier). </p> <p><code>did</code> is the unique id of the identity and <code>genesisDid</code> is the <code>did</code> of the first profile of the identity, it is the unique id of the identity for which profile nonce is 0.</p> <p>Note: It is worth noting that <code>did</code> is a Decentralized Identifier associated with an identity and enables verifiable identities. A <code>did</code> could be a person, thing, organization, or even an abstract entity. The controller of the <code>did</code> can prove that it is the real owner of the identity without the need of seeking permissions/approvals from any centralized authority. </p> <p>A <code>did</code> is expressed in the following format (as per w3.org standards):</p> <p>did: did method: did method-specific identifier</p> <p><code>privateKey</code> is the key that is used to access sensitive information related to an identity. This key is also used to generate proofs using the credentials associated with that identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-state/","title":"To Get Identity State: <code>getState</code>","text":"<p>This function returns the present state of an identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/get-state/#get-identity-state","title":"Get Identity State","text":"<p><pre><code>Future&lt;String&gt; getState(String did)\n</code></pre> getState() returns the identity state from <code>did</code>, which is the unique id of the identity. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/remove-identity/","title":"To Remove Identity: <code>removeIdentity</code>","text":"<p>In the SDK, an identity is removed using <code>removeIdentity()</code> method. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/remove-identity/#to-remove-an-identity","title":"To Remove an Identity","text":"<pre><code>Future&lt;void&gt; removeIdentity(\n      {required String genesisDid, required String privateKey}); \n</code></pre> <p>The <code>removeIdentity()</code> function removes a previously created and stored Identity from the SDK, The <code>genesisDiD</code> String and the <code>privateKey</code> are passed as parameters to the function.</p> <p><code>genesisDiD</code> is the unique id of the identity for which profile nonce as zero. </p> <p><code>privateKey</code> is the key that is used to access sensitive information related to an identity. This key is also used to generate proofs using the credentials associated with that identity.</p> <p>If an error occurs, the function throws an <code>IdentityException</code>. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/restore-identity/","title":"To Restore Identity: <code>restoreIdentity</code>","text":"<p>Restoring an Identity can be done using an identity backup and the secret used to create the identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/restore-identity/#restore-an-identity","title":"Restore an Identity","text":"<p>In the SDK, an identity is restored using <code>restoreIdentity()</code> function. It restores the <code>IdentityEntity</code> from a <code>privateKey</code>and <code>encryptedIdentityDb</code> (Encrypted Identity Database) associated with the identity. </p> <p><pre><code>Future&lt;PrivateIdentityEntity&gt; restoreIdentity(\n      {required String privateKey, required String blockchain, required String network, Map&lt;int, String&gt;? encryptedIdentityDbs});\n\n{\n   return _restoreIdentityUseCase.execute(\n        param: RestoreIdentityParam(\n      secret: secret,\n      identityBackup: encryptedIdentityDb,\n    ));\n}\n</code></pre> It returns an identity as a <code>PrivateIdentityEntity</code>. Throws <code>IdentityException</code> if an error occurs.</p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>blockchain</code> is the name of the blockchain associated with the identity. In our case, it is Polygon. </p> <p><code>network</code> is the type of network (Mainnet or Testnet) associated with the identity. </p> <p>The <code>encryptedIdentityDbs</code> stores all the sensitive information related to the identity. It is  a database where all the information associated with an identity is stored and secured by the identity (credentials, state, etc.). This information is stored in the SDK database and is accessible only by an Identity. The <code>encryptedIdentityDbs</code> are passed as a map of key:value pair where key is <code>profileNonce</code> and Value is its corresponding <code>encryptedIdentityDb</code> value.</p> <p>In short, the role of <code>restoreIdentity()</code> is to restore an <code>IdentityEntity</code> for an Integrator and then store it on the SDK. It returns the <code>PrivateIdentityEntity</code> object to the integrator to be able to operate with the identity. </p> <p>Note: <code>profileNonce</code> functionality would be a part of the next release of the Wallet SDK.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/sign/","title":"To Sign Message: <code>sign</code>","text":"<p>In the SDK, a message can be signed using the <code>sign()</code> function. </p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/identity/api/sign/#sign-a-message","title":"Sign a Message","text":"<pre><code> Future&lt;String&gt; sign(\n      {required String privateKey, required String message});\n</code></pre> <p>The <code>sign()</code> function signs a message using identity's private key; </p> <p>the <code>privateKey</code> and the <code>message</code> are passed as the input parameters to the function and a signature string is returned. </p> <p><code>privateKey</code> of the identity is a key that is used to access the sensitive information of the identity. This key is also used for generating proofs by using the credentials associated with the identity. </p> <p><code>message</code> is the actual message sent by the Integrator and it needs to be signed. </p> <p>Thus the role of <code>sign()</code> is to sign a message string for an Integrator using identity's <code>privateKey</code>.</p> <p></p> <p>Note: When an Integrator scans a QR code, an iden3 message is created. This message has a <code>challenge</code> field from which the String <code>message</code> (used as input parameter) is generated. The <code>message</code> is then used to sign with the identity to generate a signature string.</p> <p>Note: The Baby Jubjub private key is used to sign the message mentioned above. Read more about Baby Jubjub Elliptic Curve here.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/overview/","title":"Proof Generation Overview","text":"<p>The proof generation starts with the Wallet scanning the QR code on the Verifier website/app. This is worth mentioning that the proof-generation process initiates on the Verifier side first with the Verifier by generating a Query Request.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/overview/#steps-of-proof-generation","title":"Steps of Proof Generation","text":"<ol> <li> <p>Integrator selects the type of credential for which it seeks verification.</p> </li> <li> <p>Verifier website/app displays the QR code depending on the credential type selected by the Integrator.</p> </li> <li> <p>Integrator scans the QR code. By scanning, the Wallet parses the query-based authentication request shown by the Verifier. Read more about auth requests here.</p> </li> <li> <p>Before the Wallet can generate a proof, it needs to authenticate itself first. Upon successful authentication (a pin or biometrics), the Wallet starts the process of generating either a signature-based proof or a merkle-tree-based proof to be presented to the Verifier. The circuit sends back its response to the Verifier via <code>callbackUrl</code>. </p> </li> <li> <p>After the proof is sent to the Verifier that analyzes it for its authenticity and based on its analysis, verifies the proof.</p> </li> <li> <p>The Verifier shows both the authorization request and the proof information to the Integrator.</p> </li> <li> <p>As the verification is complete, an Integrator can now use the services of the Verifier. For example, if the Verifier is a DAO, the Integrator, upon successful verification, becomes a DAO member and can participate in the voting activities. </p> </li> </ol> <p>Read more about the circuits used for proof generation here.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/api/prove/","title":"To Prove: <code>prove</code>","text":"<p>The <code>prove()</code> function generates zero-knowledge proof using the valid credentials requested from the Identity.</p>"},{"location":"wallet/wallet-sdk/polygonid-sdk/proof/api/prove/#prove","title":"Prove","text":"<p>The prove() method passes <code>did</code>, <code>profileNonce</code>, <code>claim</code>, <code>circuitData</code>, <code>request</code>, and <code>challenge</code> as input parameters. and generates a JWZ proof. </p> <pre><code>Future&lt;JWZProof&gt; prove(\n      {required String did,\n      int? profileNonce,  \n      required ClaimEntity claim,\n      required CircuitDataEntity circuitData, required ProofScopeRequest request, String? privateKey, String? challenge});\n\n   Future&lt;Stream&lt;DownloadInfo&gt;&gt; get initCircuitsDownloadAndGetInfoStream;\n\n  Future&lt;bool&gt; isAlreadyDownloadedCircuitsFromServer(); \n  }\n</code></pre> <p><code>did</code> is the unique id of the identity <code>profileNonce</code> is the nonce of the profile of the identity <code>claim</code> is Verifiable Credential  <code>circuitData</code> are the circuits used for generating a proof <code>request</code> is the proof request information that comes from the Verifier. <code>challenge</code> is a message the Verifier requires an Integrator to sign with its identity so that an Integrator can verify its identity</p> <p><code>initCircuitsDownloadAndGetInfoStream()</code> and <code>isAlreadyDownloadedCircuitsFromServer()</code> methods above are used for downloading the circuit files as these circuits are too big to be stored on the SDK. </p> <p>The <code>prove()</code> function generates a <code>JWZProof</code> that fulfills the proof query parameters with valid identity and credentials. This proof is shared by an Integrator with a Verifier. The <code>prove()</code> returns a <code>JWZProof</code> object so that the Integrator is able to verify the requested information (requested from Identity) with the Verifier. </p>"}]}